<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta http-equiv="X-UA-Compatible" content="ie=edge"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
  <title>Moon AI Trading Platform | Advanced Market Analysis</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link
    href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&display=swap"
    rel="stylesheet"
  />

  <!-- Design Tokens - Unified Theme System v7.0 -->
  <link rel="stylesheet" href="src/styles/design-tokens.css"/>
  <!-- TradingView Atomic CSS System v6.5 -->
  <link rel="stylesheet" href="src/styles/tradingview-atomic.css"/>

  <!-- Enterprise Styles v5.0 - Webull Killer -->
  <style>
    :root {
      /* === CORE COLORS === */
      --primary-color: #6c5ce7;
      --primary-light: #a29bfe;
      --primary-dark: #5849c2;
      --secondary-color: #00cec9;
      --accent-color: #fd79a8;
      --background-color: #0a0a12;
      --card-background: #12121e;
      --panel-background: #0f0f1a;
      --text-color: #e8e8f0;
      --text-secondary: #8b8b9a;
      --text-muted: #5a5a6a;
      --border-color: #1e1e2d;
      --border-light: #2d2d3d;

      /* === LAYOUT DIMENSIONS === */
      --header-height: 52px;
      --sidebar-width: 240px;
      --right-panel-width: 320px;
      --widgetbar-width: 44px;
      --execution-bar-height: 64px;

      /* === TRADING COLORS === */
      --success: #00d26a;
      --success-light: rgba(0, 210, 106, 0.15);
      --success-glow: rgba(0, 210, 106, 0.4);
      --warning: #ffb74d;
      --warning-light: rgba(255, 183, 77, 0.15);
      --danger: #ff5252;
      --danger-light: rgba(255, 82, 82, 0.15);
      --danger-glow: rgba(255, 82, 82, 0.4);
      --chart-bull: #00d26a;
      --chart-bear: #ff5252;
      --grid-color: rgba(255, 255, 255, 0.04);

      /* === SIGNAL GRADES === */
      --grade-a-plus: #ff4757;
      --grade-a-plus-glow: 0 0 20px rgba(255, 71, 87, 0.6);
      --grade-a: #ffd700;
      --grade-a-glow: 0 0 20px rgba(255, 215, 0, 0.5);
      --grade-b: #3498db;
      --grade-b-glow: 0 0 15px rgba(52, 152, 219, 0.4);
      --grade-c: #95a5a6;

      /* === GLASSMORPHISM === */
      --glass-bg: rgba(18, 18, 30, 0.85);
      --glass-border: rgba(255, 255, 255, 0.08);
      --glass-blur: blur(12px);

      /* === TRANSITIONS === */
      --transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-bounce: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);

      /* === SHADOWS === */
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);
      --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);
      --shadow-glow: 0 0 30px rgba(108, 92, 231, 0.3);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Outfit', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      line-height: 1.6;
      overflow: hidden;
    }

    h1, h2, h3, h4, h5, h6 {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    /* Header */
    .platform-header {
      height: var(--header-height);
      background-color: var(--card-background);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
    }

    .logo {
      font-size: 24px;
      font-weight: bold;
      color: var(--text-color);
      display: flex;
      align-items: center;
    }

    .logo-icon {
      margin-right: 10px;
      font-size: 28px;
      color: var(--primary-color);
    }

    .logo span {
      background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      font-weight: 800;
    }

    .search-bar {
      width: 300px;
      position: relative;
    }

    .search-bar input {
      width: 100%;
      padding: 8px 12px;
      background-color: rgba(40, 40, 80, 0.5);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-color);
    }

    .user-controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .platform-button {
      padding: 8px 16px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .platform-button:hover {
      background-color: var(--primary-light);
    }

    .platform-button.secondary {
      background-color: transparent;
      border: 1px solid var(--primary-color);
      color: var(--primary-light);
    }

    .platform-button.secondary:hover {
      background-color: rgba(108, 92, 231, 0.1);
    }

    .user-profile {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background-color: var(--primary-color);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      cursor: pointer;
    }

    /* === ENTERPRISE CSS GRID LAYOUT === */
    .platform-container {
      display: grid;
      grid-template-columns: var(--sidebar-width) 1fr var(--right-panel-width);
      grid-template-rows: 1fr var(--execution-bar-height);
      grid-template-areas:
        "sidebar chart panels"
        "execution execution execution";
      height: calc(100vh - var(--header-height));
      margin-top: var(--header-height);
      gap: 0;
      transition: var(--transition-smooth);
      background: var(--background-color);
    }

    /* Sidebar collapsed state - chart expands magnetically */
    .platform-container.sidebar-collapsed {
      grid-template-columns: 0 1fr var(--right-panel-width);
    }

    /* Panels collapsed state */
    .platform-container.panels-collapsed {
      grid-template-columns: var(--sidebar-width) 1fr 0;
    }

    /* Both collapsed - 100% chart */
    .platform-container.sidebar-collapsed.panels-collapsed {
      grid-template-columns: 0 1fr 0;
    }

    /* === LEFT SIDEBAR (Watchlist) === */
    .left-sidebar {
      grid-area: sidebar;
      background: var(--card-background);
      border-right: 1px solid var(--border-color);
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      transition: var(--transition-smooth);
      will-change: width;
    }

    .platform-container.sidebar-collapsed .left-sidebar {
      width: 0;
      min-width: 0;
      border-right: none;
      overflow: hidden;
    }

    .sidebar-toggle {
      position: fixed;
      top: calc(var(--header-height) + 12px);
      left: calc(var(--sidebar-width) - 12px);
      z-index: 101;
      width: 24px;
      height: 24px;
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 10px;
      color: var(--text-secondary);
      transition: var(--transition-smooth);
      box-shadow: var(--shadow-sm);
    }

    .sidebar-toggle:hover {
      background: var(--primary-color);
      color: white;
      transform: scale(1.1);
    }

    .sidebar-toggle.collapsed {
      left: 12px;
    }

    /* Watchlist Header */
    .watchlist-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--panel-background);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .watchlist-header h3 {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-color);
      margin: 0;
    }

    /* === MAIN CHART AREA === */
    .chart-area {
      grid-area: chart;
      position: relative;
      background: var(--background-color);
      overflow: hidden;
      min-width: 0;
    }

    /* === RIGHT PANELS === */
    .right-panels {
      grid-area: panels;
      background: var(--card-background);
      border-left: 1px solid var(--border-color);
      overflow-y: auto;
      overflow-x: hidden;
      margin-right: var(--widgetbar-width); /* Account for widgetbar */
      transition: var(--transition-smooth);
      will-change: width;
    }

    .platform-container.panels-collapsed .right-panels,
    .platform-container.right-panel-collapsed .right-panels {
      width: 0;
      min-width: 0;
      border-left: none;
      overflow: hidden;
      margin-right: var(--widgetbar-width);
    }

    /* Grid layout when right panel is collapsed */
    .platform-container.right-panel-collapsed {
      grid-template-columns: var(--sidebar-width) 1fr 0;
    }

    .platform-container.right-panel-collapsed main,
    .platform-container.right-panel-collapsed .chart-area {
      margin-right: var(--widgetbar-width);
    }

    /* === WIDGETBAR HIDER (TradingView-Style Panel Toggle) === */
    .panels-toggle.widgetbar-hider {
      position: fixed;
      right: calc(var(--right-panel-width) + var(--widgetbar-width) - 4px);
      top: 50%;
      transform: translateY(-50%);
      z-index: 150;
      cursor: pointer;
      transition: right 0.25s ease, transform 0.15s ease;
      width: auto;
      height: auto;
      background: transparent;
      border: none;
      border-radius: 0;
      box-shadow: none;
      padding: 0;
    }

    .panels-toggle.widgetbar-hider .hider-inner {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .panels-toggle.widgetbar-hider .hider-svg {
      display: block;
    }

    .panels-toggle.widgetbar-hider .background-pill {
      fill: var(--border-color);
      stroke: var(--border-color);
      stroke-width: 1;
      transition: fill 0.15s ease, stroke 0.15s ease;
    }

    .panels-toggle.widgetbar-hider .arrow-icon {
      stroke: var(--text-secondary);
      stroke-width: 1.5;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke 0.15s ease, transform 0.25s ease;
    }

    .panels-toggle.widgetbar-hider:hover .background-pill {
      fill: var(--primary-color);
      stroke: var(--primary-color);
    }

    .panels-toggle.widgetbar-hider:hover .arrow-icon {
      stroke: white;
    }

    /* Collapsed state - panel hidden, arrow points left (show panel) */
    .panels-toggle.widgetbar-hider.collapsed {
      right: calc(var(--widgetbar-width) - 4px);
    }

    .panels-toggle.widgetbar-hider.collapsed .hider-svg {
      transform: scaleX(-1);
    }

    /* Tooltip for widgetbar hider */
    .panels-toggle.widgetbar-hider .tv-tooltip {
      position: absolute;
      right: 100%;
      top: 50%;
      transform: translateY(-50%);
      margin-right: 8px;
      background: var(--tooltip-bg, #1e222d);
      color: var(--tooltip-text, #d1d4dc);
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.15s ease, visibility 0.15s ease;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .panels-toggle.widgetbar-hider:hover .tv-tooltip {
      opacity: 1;
      visibility: visible;
    }

    /* Legacy panels-toggle fallback (hidden when widgetbar-hider is used) */
    .panels-toggle:not(.widgetbar-hider) {
      position: fixed;
      top: calc(var(--header-height) + 12px);
      right: calc(var(--right-panel-width) - 12px);
      z-index: 101;
      width: 24px;
      height: 24px;
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 10px;
      color: var(--text-secondary);
      transition: var(--transition-smooth);
      box-shadow: var(--shadow-sm);
    }

    .panels-toggle:not(.widgetbar-hider):hover {
      background: var(--primary-color);
      color: white;
      transform: scale(1.1);
    }

    .panels-toggle:not(.widgetbar-hider).collapsed {
      right: 12px;
    }

    /* === EXECUTION BAR (1-Click Trading) === */
    .execution-bar {
      grid-area: execution;
      background: linear-gradient(180deg, var(--card-background) 0%, var(--panel-background) 100%);
      border-top: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      padding-right: calc(20px + var(--widgetbar-width)); /* Account for widgetbar */
      gap: 20px;
    }

    /* Symbol + Live Price */
    .trade-header {
      display: flex;
      align-items: center;
      gap: 16px;
      min-width: 200px;
    }

    .symbol-info {
      display: flex;
      align-items: baseline;
      gap: 10px;
    }

    .symbol-info .symbol {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-color);
    }

    .symbol-info .price {
      font-size: 20px;
      font-weight: 600;
      color: var(--text-color);
      font-variant-numeric: tabular-nums;
    }

    .symbol-info .price.live {
      animation: price-pulse 2s ease-in-out infinite;
    }

    @keyframes price-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .symbol-info .change {
      font-size: 14px;
      font-weight: 500;
      padding: 2px 8px;
      border-radius: 4px;
    }

    .symbol-info .change.positive {
      color: var(--success);
      background: var(--success-light);
    }

    .symbol-info .change.negative {
      color: var(--danger);
      background: var(--danger-light);
    }

    .live-pnl {
      font-size: 16px;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
    }

    .live-pnl.positive { color: var(--success); }
    .live-pnl.negative { color: var(--danger); }

    /* Quick Trade Buttons */
    .quick-trade {
      display: flex;
      gap: 12px;
    }

    .trade-btn {
      padding: 10px 32px;
      font-size: 16px;
      font-weight: 700;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: var(--transition-fast);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .trade-btn.buy {
      background: var(--success);
      color: white;
    }

    .trade-btn.buy:hover {
      background: #00e676;
      box-shadow: 0 0 20px var(--success-glow);
      transform: translateY(-1px);
    }

    .trade-btn.sell {
      background: var(--danger);
      color: white;
    }

    .trade-btn.sell:hover {
      background: #ff6b6b;
      box-shadow: 0 0 20px var(--danger-glow);
      transform: translateY(-1px);
    }

    .trade-btn.glow {
      animation: btn-glow 3s ease-in-out infinite;
    }

    @keyframes btn-glow {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.1); }
    }

    /* Position Sizer */
    .position-sizer {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .size-presets {
      display: flex;
      gap: 6px;
    }

    .size-presets .preset {
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: var(--transition-fast);
    }

    .size-presets .preset:hover {
      background: rgba(108, 92, 231, 0.2);
      border-color: var(--primary-color);
      color: var(--primary-light);
    }

    .size-presets .preset.active {
      background: var(--primary-color);
      border-color: var(--primary-color);
      color: white;
    }

    .risk-metrics {
      display: flex;
      gap: 12px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .risk-metrics .rr {
      color: var(--success);
      font-weight: 500;
    }

    .risk-metrics .stop {
      color: var(--danger);
    }

    /* Emergency Stop */
    .emergency-stop {
      padding: 10px 20px;
      font-size: 12px;
      font-weight: 700;
      background: transparent;
      border: 2px solid var(--danger);
      border-radius: 6px;
      color: var(--danger);
      cursor: pointer;
      transition: var(--transition-fast);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .emergency-stop:hover {
      background: var(--danger);
      color: white;
      box-shadow: 0 0 20px var(--danger-glow);
      animation: emergency-pulse 0.5s ease-in-out infinite;
    }

    @keyframes emergency-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    /* Auth Modal */
    .auth-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(15, 15, 26, 0.9);
      backdrop-filter: blur(8px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    .auth-modal.visible {
      opacity: 1;
      visibility: visible;
    }

    .auth-container {
      background-color: var(--card-background);
      border-radius: 10px;
      width: 100%;
      max-width: 400px;
      padding: 30px;
      box-shadow: 0 15px 30px rgba(0,0,0,0.3);
      transform: translateY(20px);
      transition: all 0.3s ease;
    }
    .auth-modal.visible .auth-container {
      transform: translateY(0);
    }
    .auth-header {
      margin-bottom: 25px;
      text-align: center;
    }
    .auth-header h2 {
      font-size: 24px;
      margin-bottom: 10px;
      background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .auth-tabs {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 1px solid var(--border-color);
    }
    .auth-tab {
      flex: 1;
      padding: 12px;
      text-align: center;
      cursor: pointer;
      color: var(--text-secondary);
      transition: all 0.2s ease;
    }
    .auth-tab.active {
      color: var(--primary-light);
      border-bottom: 2px solid var(--primary-color);
    }

    .auth-form {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .form-group label {
      font-size: 14px;
      color: var(--text-secondary);
    }
    .form-group input {
      width: 100%;
      padding: 12px;
      background-color: rgba(40,40,80,0.5);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-color);
      font-size: 16px;
      transition: all 0.2s ease;
    }
    .auth-button {
      padding: 12px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 10px;
      transition: background-color 0.2s ease;
    }
    .auth-button:hover {
      background-color: var(--primary-light);
    }
    .auth-message {
      text-align: center;
      color: var(--danger);
      font-size: 14px;
      min-height: 20px;
      margin-top: 10px;
    }

    /* Stock Item (for watchlist) */
    .stock-item {
      padding: 12px 15px;
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
      transition: background-color 0.2s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .stock-item:hover {
      background-color: rgba(108, 92, 231, 0.1);
    }
    .stock-item.active {
      background-color: rgba(108, 92, 231, 0.15);
      border-left: 3px solid var(--primary-color);
    }
    .stock-symbol {
      font-weight: 700;
      font-size: 16px;
    }
    .stock-company {
      font-size: 12px;
      color: var(--text-secondary);
    }
    .stock-price {
      font-weight: 600;
    }
    .stock-change {
      font-size: 12px;
    }
    .stock-change.positive {
      color: var(--success);
    }
    .stock-change.negative {
      color: var(--danger);
    }

    /* === SIGNAL GRADING SYSTEM (A+/A/B/C) === */
    .signal-grade {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 36px;
      height: 28px;
      padding: 0 8px;
      border-radius: 6px;
      font-weight: 700;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: var(--transition-smooth);
    }

    .signal-grade.grade-a-plus {
      background: linear-gradient(135deg, var(--grade-a-plus), #ff6b7a);
      color: white;
      box-shadow: var(--grade-a-plus-glow);
      animation: grade-glow-aplus 2s ease-in-out infinite;
    }

    .signal-grade.grade-a {
      background: linear-gradient(135deg, var(--grade-a), #ff9f43);
      color: white;
      box-shadow: var(--grade-a-glow);
      animation: grade-glow-a 2s ease-in-out infinite;
    }

    .signal-grade.grade-b {
      background: linear-gradient(135deg, var(--grade-b), #ffeaa7);
      color: #1a1a2e;
      box-shadow: var(--grade-b-glow);
    }

    .signal-grade.grade-c {
      background: var(--grade-c);
      color: var(--text-secondary);
      border: 1px solid var(--border-color);
    }

    @keyframes grade-glow-aplus {
      0%, 100% { box-shadow: var(--grade-a-plus-glow); }
      50% { box-shadow: 0 0 30px rgba(255, 71, 87, 0.8), 0 0 60px rgba(255, 71, 87, 0.4); }
    }

    @keyframes grade-glow-a {
      0%, 100% { box-shadow: var(--grade-a-glow); }
      50% { box-shadow: 0 0 25px rgba(255, 165, 2, 0.7), 0 0 50px rgba(255, 165, 2, 0.3); }
    }

    /* Signal Card with Grade */
    .signal-card {
      background: var(--panel-background);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 14px;
      margin-bottom: 12px;
      transition: var(--transition-smooth);
      cursor: pointer;
    }

    .signal-card:hover {
      border-color: var(--primary-color);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .signal-card.grade-a-plus {
      border-color: rgba(255, 71, 87, 0.4);
      background: linear-gradient(135deg, rgba(255, 71, 87, 0.1), transparent);
    }

    .signal-card.grade-a {
      border-color: rgba(255, 165, 2, 0.3);
      background: linear-gradient(135deg, rgba(255, 165, 2, 0.08), transparent);
    }

    .signal-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .signal-card-symbol {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .signal-card-symbol .symbol {
      font-size: 15px;
      font-weight: 700;
      color: var(--text-color);
    }

    .signal-card-symbol .direction {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      font-weight: 600;
      padding: 3px 8px;
      border-radius: 4px;
    }

    .signal-card-symbol .direction.long {
      color: var(--success);
      background: var(--success-light);
    }

    .signal-card-symbol .direction.short {
      color: var(--danger);
      background: var(--danger-light);
    }

    .signal-card-metrics {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      font-size: 12px;
    }

    .signal-metric {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .signal-metric label {
      color: var(--text-muted);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .signal-metric value {
      color: var(--text-color);
      font-weight: 600;
      font-variant-numeric: tabular-nums;
    }

    .signal-metric value.positive { color: var(--success); }
    .signal-metric value.negative { color: var(--danger); }

    /* === ENHANCED PANELS === */
    .panel {
      margin: 15px;
      background-color: var(--panel-background);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .panel h3 {
      margin-bottom: 0;
      color: var(--primary-light);
    }
    .panel-content {
      font-size: 14px;
      color: var(--text-secondary);
      min-height: 80px;
    }
    .panel-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      padding: 20px;
    }
    .panel-loading .mini-loader {
      width: 24px;
      height: 24px;
      border: 2px solid rgba(108,92,231,0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }

    /* === PANEL HEADER CONTROLS - Detach & Link UI === */
    .panel-header-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .panel-detach-btn {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: 1px solid var(--color-border, rgba(255,255,255,0.06));
      border-radius: 4px;
      color: var(--color-text-muted, rgba(255,255,255,0.4));
      cursor: pointer;
      transition: all 150ms ease;
    }

    .panel-detach-btn:hover {
      background: var(--color-surface-hover, #2a2e39);
      color: var(--color-text, rgba(255,255,255,0.9));
      border-color: var(--color-border-hover, rgba(255,255,255,0.12));
    }

    .panel-detach-btn svg {
      width: 14px;
      height: 14px;
    }

    .panel-link-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 4px;
      transition: all 150ms ease;
    }

    .panel-link-indicator:hover {
      background: var(--color-surface-hover, #2a2e39);
    }

    .panel-link-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      box-shadow: 0 0 4px currentColor;
    }

    .panel-link-dot.blue { background-color: var(--color-link-blue, #2962ff); }
    .panel-link-dot.green { background-color: var(--color-link-green, #26a69a); }
    .panel-link-dot.orange { background-color: var(--color-link-orange, #ff9800); }
    .panel-link-dot.purple { background-color: var(--color-link-purple, #6c5ce7); }
    .panel-link-dot.master { background-color: var(--color-link-master, #ffffff); }
    .panel-link-dot.none { background-color: var(--color-link-none, #5a5a6a); }

    /* === PANEL HEADER LEFT === */
    .panel-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .panel-header-left h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
    }

    /* === PANEL TABS (AI, Screener, News) === */
    .ai-tabs, .screener-tabs, .news-tabs, .calendar-filters, .signal-filters {
      display: flex;
      gap: 2px;
      background: var(--color-surface, #1e222d);
      border-radius: 4px;
      padding: 2px;
    }

    .ai-tab-btn, .screener-tab-btn, .news-tab-btn, .calendar-filter-btn, .signal-filter-btn {
      padding: 4px 8px;
      font-size: 11px;
      background: transparent;
      border: none;
      color: var(--color-text-muted, rgba(255,255,255,0.4));
      border-radius: 3px;
      cursor: pointer;
      transition: all 150ms ease;
    }

    .ai-tab-btn:hover, .screener-tab-btn:hover, .news-tab-btn:hover,
    .calendar-filter-btn:hover, .signal-filter-btn:hover {
      color: var(--color-text, rgba(255,255,255,0.9));
      background: var(--color-surface-hover, #2a2e39);
    }

    .ai-tab-btn.active, .screener-tab-btn.active, .news-tab-btn.active,
    .calendar-filter-btn.active, .signal-filter-btn.active {
      color: var(--color-text, rgba(255,255,255,0.9));
      background: var(--color-primary-light, rgba(41,98,255,0.2));
    }

    .ai-tab-content, .news-tab-content {
      display: none;
    }

    .ai-tab-content.active, .news-tab-content.active {
      display: block;
    }

    /* === AI CHAT === */
    .ai-chat-messages {
      min-height: 150px;
      max-height: 300px;
      overflow-y: auto;
      padding: 10px 0;
    }

    .ai-message {
      padding: 8px 12px;
      margin-bottom: 8px;
      border-radius: 8px;
      font-size: 13px;
      line-height: 1.4;
    }

    .ai-message.assistant {
      background: var(--color-surface, #1e222d);
      color: var(--color-text, rgba(255,255,255,0.9));
    }

    .ai-message.user {
      background: var(--color-primary-light, rgba(41,98,255,0.2));
      color: var(--color-text, rgba(255,255,255,0.9));
      margin-left: 20px;
    }

    .ai-chat-input {
      display: flex;
      gap: 8px;
      padding-top: 10px;
      border-top: 1px solid var(--color-border, rgba(255,255,255,0.06));
    }

    .ai-chat-input input {
      flex: 1;
      padding: 8px 12px;
      background: var(--color-surface, #1e222d);
      border: 1px solid var(--color-border, rgba(255,255,255,0.06));
      border-radius: 4px;
      color: var(--color-text, rgba(255,255,255,0.9));
      font-size: 13px;
    }

    .ai-chat-send {
      padding: 8px 16px;
      background: var(--color-primary, #2962ff);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
    }

    .ai-chat-send:hover {
      background: var(--color-primary-hover, #1e53e4);
    }

    /* === PINE EDITOR === */
    .pine-editor {
      width: 100%;
      min-height: 200px;
      background: var(--color-bg, #131722);
      border: 1px solid var(--color-border, rgba(255,255,255,0.06));
      border-radius: 4px;
      color: var(--color-text, rgba(255,255,255,0.9));
      font-family: var(--font-family-mono, 'SF Mono', monospace);
      font-size: 12px;
      padding: 10px;
      resize: vertical;
    }

    .pine-actions {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    .pine-action-btn, .pine-run-btn, .pine-apply-btn {
      padding: 6px 12px;
      font-size: 11px;
      background: var(--color-surface-hover, #2a2e39);
      border: 1px solid var(--color-border, rgba(255,255,255,0.06));
      color: var(--color-text, rgba(255,255,255,0.9));
      border-radius: 4px;
      cursor: pointer;
      transition: all 150ms ease;
    }

    .pine-run-btn {
      background: var(--color-primary, #2962ff);
      border-color: var(--color-primary, #2962ff);
      color: white;
    }

    .pine-apply-btn {
      background: var(--color-success, #26a69a);
      border-color: var(--color-success, #26a69a);
      color: white;
    }

    /* === NOTIFICATIONS === */
    .notification-item {
      display: flex;
      gap: 12px;
      padding: 12px;
      border-bottom: 1px solid var(--color-border, rgba(255,255,255,0.06));
      cursor: pointer;
      transition: background 150ms ease;
    }

    .notification-item:hover {
      background: var(--color-surface-hover, #2a2e39);
    }

    .notification-item.unread {
      background: var(--color-primary-lighter, rgba(41,98,255,0.1));
    }

    .notification-icon {
      font-size: 20px;
    }

    .notification-text {
      flex: 1;
    }

    .notification-title {
      font-weight: 500;
      color: var(--color-text, rgba(255,255,255,0.9));
      font-size: 13px;
    }

    .notification-desc {
      font-size: 12px;
      color: var(--color-text-secondary, rgba(255,255,255,0.6));
      margin-top: 2px;
    }

    .notification-time {
      font-size: 11px;
      color: var(--color-text-muted, rgba(255,255,255,0.4));
      margin-top: 4px;
    }

    .mark-all-read-btn {
      padding: 4px 8px;
      font-size: 11px;
      background: transparent;
      border: 1px solid var(--color-border, rgba(255,255,255,0.06));
      color: var(--color-text-secondary, rgba(255,255,255,0.6));
      border-radius: 4px;
      cursor: pointer;
      transition: all 150ms ease;
    }

    .mark-all-read-btn:hover {
      background: var(--color-surface-hover, #2a2e39);
      color: var(--color-text, rgba(255,255,255,0.9));
    }

    /* === SETTINGS === */
    .settings-section {
      margin-bottom: 20px;
    }

    .settings-section h4 {
      font-size: 12px;
      font-weight: 600;
      color: var(--color-text-secondary, rgba(255,255,255,0.6));
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }

    .setting-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
    }

    .setting-item label {
      font-size: 13px;
      color: var(--color-text, rgba(255,255,255,0.9));
    }

    .setting-select {
      padding: 6px 10px;
      background: var(--color-surface, #1e222d);
      border: 1px solid var(--color-border, rgba(255,255,255,0.06));
      border-radius: 4px;
      color: var(--color-text, rgba(255,255,255,0.9));
      font-size: 12px;
    }

    /* === HELP === */
    .help-section {
      margin-bottom: 20px;
    }

    .help-section h4 {
      font-size: 12px;
      font-weight: 600;
      color: var(--color-text-secondary, rgba(255,255,255,0.6));
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }

    .shortcut-item {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      font-size: 13px;
    }

    .shortcut-key {
      background: var(--color-surface, #1e222d);
      padding: 2px 8px;
      border-radius: 4px;
      font-family: var(--font-family-mono, 'SF Mono', monospace);
      font-size: 11px;
      color: var(--color-text-secondary, rgba(255,255,255,0.6));
    }

    .shortcut-desc {
      color: var(--color-text, rgba(255,255,255,0.9));
    }

    .help-link {
      display: block;
      padding: 8px 0;
      color: var(--color-primary, #2962ff);
      text-decoration: none;
      font-size: 13px;
    }

    .help-link:hover {
      text-decoration: underline;
    }

    /* === SCREENER === */
    .screener-filters {
      margin-bottom: 10px;
    }

    .screener-filter-select {
      width: 100%;
      padding: 8px 12px;
      background: var(--color-surface, #1e222d);
      border: 1px solid var(--color-border, rgba(255,255,255,0.06));
      border-radius: 4px;
      color: var(--color-text, rgba(255,255,255,0.9));
      font-size: 12px;
    }

    .screener-loading, .calendar-loading {
      text-align: center;
      padding: 20px;
      color: var(--color-text-muted, rgba(255,255,255,0.4));
      font-size: 13px;
    }

    /* === WATCHLIST === */
    .watchlist-search-input {
      width: 100%;
      padding: 8px 12px;
      background: var(--color-surface, #1e222d);
      border: 1px solid var(--color-border, rgba(255,255,255,0.06));
      border-radius: 4px;
      color: var(--color-text, rgba(255,255,255,0.9));
      font-size: 12px;
      margin-bottom: 10px;
    }

    /* === ENHANCED CHART HEADER + TOOLBAR === */
    .chart-header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      border-bottom: 1px solid var(--glass-border);
      z-index: 25;
    }

    .chart-symbol-display {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .chart-symbol-display .symbol {
      font-size: 16px;
      font-weight: 700;
      color: var(--text-color);
    }

    .chart-symbol-display .price-display {
      display: flex;
      align-items: baseline;
      gap: 8px;
    }

    .chart-symbol-display .current-price {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-color);
      font-variant-numeric: tabular-nums;
    }

    .chart-symbol-display .price-change {
      font-size: 13px;
      font-weight: 500;
      padding: 2px 6px;
      border-radius: 4px;
    }

    .chart-symbol-display .price-change.up {
      color: var(--success);
      background: var(--success-light);
    }

    .chart-symbol-display .price-change.down {
      color: var(--danger);
      background: var(--danger-light);
    }

    .chart-toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toolbar-group {
      display: flex;
      gap: 4px;
      background: var(--panel-background);
      padding: 4px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .toolbar-separator {
      width: 1px;
      height: 24px;
      background: var(--border-color);
      margin: 0 4px;
    }

    .control-button {
      background: transparent;
      color: var(--text-secondary);
      border: none;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: var(--transition-smooth);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .control-button:hover {
      background: rgba(108, 92, 231, 0.15);
      color: var(--primary-light);
    }

    .control-button.active {
      background: var(--primary-color);
      color: white;
    }

    .control-button .icon {
      font-size: 14px;
    }

    /* Chart Type Selector */
    .chart-type-selector {
      display: flex;
      gap: 2px;
    }

    .chart-type-btn {
      padding: 6px 8px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
      transition: var(--transition-smooth);
    }

    .chart-type-btn:hover {
      color: var(--text-secondary);
      background: rgba(255, 255, 255, 0.05);
    }

    .chart-type-btn.active {
      color: var(--primary-light);
      background: rgba(108, 92, 231, 0.2);
    }

    /* Timeframe Controls - Floating */
    .timeframe-controls {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      display: flex;
      gap: 4px;
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid var(--glass-border);
      box-shadow: var(--shadow-lg);
    }

    .timeframe-button {
      padding: 6px 12px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      border-radius: 6px;
      transition: var(--transition-smooth);
      color: var(--text-secondary);
      background: transparent;
      border: none;
    }

    .timeframe-button:hover {
      background: rgba(108, 92, 231, 0.15);
      color: var(--primary-light);
    }

    .timeframe-button.active {
      background: var(--primary-color);
      color: white;
      box-shadow: 0 2px 8px rgba(108, 92, 231, 0.4);
    }

    /* === PORTFOLIO PANEL WITH VaR === */
    .portfolio-panel {
      background: var(--panel-background);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 16px;
      margin: 12px;
    }

    .portfolio-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .portfolio-header h3 {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-color);
      margin: 0;
    }

    .portfolio-value {
      text-align: center;
      padding: 16px;
      background: linear-gradient(135deg, rgba(108, 92, 231, 0.1), rgba(162, 155, 254, 0.05));
      border-radius: 10px;
      margin-bottom: 16px;
    }

    .portfolio-value .label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .portfolio-value .amount {
      font-size: 24px;
      font-weight: 700;
      color: var(--text-color);
      font-variant-numeric: tabular-nums;
    }

    .portfolio-value .daily-change {
      font-size: 13px;
      font-weight: 600;
      margin-top: 4px;
    }

    .portfolio-value .daily-change.positive { color: var(--success); }
    .portfolio-value .daily-change.negative { color: var(--danger); }

    /* Risk Metrics Grid */
    .risk-metrics {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-bottom: 16px;
    }

    .risk-metric {
      background: var(--card-background);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
    }

    .risk-metric .label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .risk-metric .label .info-icon {
      font-size: 10px;
      cursor: help;
      opacity: 0.5;
    }

    .risk-metric .value {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-color);
      font-variant-numeric: tabular-nums;
    }

    .risk-metric .value.warning { color: var(--warning); }
    .risk-metric .value.danger { color: var(--danger); }
    .risk-metric .value.success { color: var(--success); }

    /* VaR Special Display */
    .var-display {
      background: linear-gradient(135deg, rgba(255, 71, 87, 0.1), rgba(255, 107, 107, 0.05));
      border: 1px solid rgba(255, 71, 87, 0.2);
      border-radius: 10px;
      padding: 14px;
    }

    .var-display .var-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .var-display .var-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
    }

    .var-display .var-confidence {
      font-size: 10px;
      color: var(--text-muted);
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
    }

    .var-display .var-value {
      font-size: 20px;
      font-weight: 700;
      color: var(--danger);
      font-variant-numeric: tabular-nums;
    }

    .var-display .var-percentage {
      font-size: 12px;
      color: var(--text-muted);
      margin-left: 6px;
    }

    /* Position List in Portfolio */
    .position-list {
      margin-top: 16px;
    }

    .position-list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .position-list-header h4 {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      margin: 0;
    }

    .position-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background: var(--card-background);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-bottom: 8px;
      transition: var(--transition-smooth);
    }

    .position-item:hover {
      border-color: var(--primary-color);
    }

    .position-item .position-info {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .position-item .position-symbol {
      font-weight: 600;
      font-size: 13px;
      color: var(--text-color);
    }

    .position-item .position-size {
      font-size: 11px;
      color: var(--text-muted);
    }

    .position-item .position-pnl {
      font-size: 13px;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
    }

    .position-item .position-pnl.positive { color: var(--success); }
    .position-item .position-pnl.negative { color: var(--danger); }

    /* Loading States */
    .loading-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(15,15,26,0.8);
      display: flex; justify-content: center; align-items: center;
      z-index: 1000;
      opacity: 1;
      transition: opacity 0.3s ease-out;
    }
    .loading-overlay.fade-out {
      opacity: 0;
      pointer-events: none;
    }
    .loader-container {
      text-align: center;
      max-width: 80%;
    }
    .loader {
      width: 60px; height: 60px;
      border: 4px solid rgba(108,92,231,0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    .loading-message {
      color: var(--text-color);
      font-size: 18px;
      margin-bottom: 25px;
    }
    .loading-progress {
      width: 100%;
      max-width: 300px;
      height: 4px;
      background-color: rgba(255,255,255,0.1);
      border-radius: 2px;
      margin: 0 auto;
      overflow: hidden;
    }
    .loading-progress-bar {
      height: 100%;
      width: 10%;
      background-color: var(--primary-color);
      border-radius: 2px;
      transition: width 0.3s ease;
    }
    .loading-tasks {
      font-size: 14px;
      color: var(--text-secondary);
      margin-top: 15px;
      text-align: left;
      max-width: 300px;
      margin: 15px auto 0;
    }
    .loading-task {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    .loading-task-status {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 10px;
    }
    .loading-task-pending {
      width: 12px;
      height: 12px;
      border: 2px solid rgba(108,92,231,0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s linear infinite;
    }
    .loading-task-complete {
      color: var(--success);
      font-size: 16px;
    }
    
    /* Skeleton Loaders for Panels */
    .skeleton {
      background: linear-gradient(90deg, var(--panel-background) 0%, rgba(42, 46, 73, 0.5) 50%, var(--panel-background) 100%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s infinite;
      border-radius: 4px;
      height: 12px;
      margin-bottom: 8px;
    }
    .skeleton-heading {
      width: 70%;
      height: 16px;
    }
    .skeleton-text {
      width: 100%;
    }
    .skeleton-text-short {
      width: 50%;
    }
    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    /* Chart Container */
    .chart-wrapper {
      background-color: var(--card-background);
      border-radius: 10px;
      overflow: hidden;
      height: 100%;
      position: relative;
    }
    .chart-loading {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(26, 26, 46, 0.6);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 1;
      transition: opacity 0.3s ease;
      z-index: 5;
    }
    .chart-loading.loaded {
      opacity: 0;
      pointer-events: none;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      background-color: rgba(26, 26, 46, 0.9);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.2s;
      max-width: 240px;
      border: 1px solid var(--border-color);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }
    .tooltip.visible {
      opacity: 1;
    }

    /* Toast Notifications */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 320px;
    }
    .toast {
      background-color: rgba(26, 26, 46, 0.9);
      border-left: 4px solid var(--primary-color);
      padding: 12px 15px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      animation: toast-in 0.3s ease forwards;
      max-width: 100%;
    }
    .toast.error {
      border-left-color: var(--danger);
    }
    .toast.success {
      border-left-color: var(--success);
    }
    .toast.warning {
      border-left-color: var(--warning);
    }
    .toast-icon {
      margin-right: 10px;
      font-size: 18px;
      color: var(--primary-color);
    }
    .toast.error .toast-icon {
      color: var(--danger);
    }
    .toast.success .toast-icon {
      color: var(--success);
    }
    .toast.warning .toast-icon {
      color: var(--warning);
    }
    .toast-content {
      flex: 1;
    }
    .toast-title {
      font-weight: 600;
      margin-bottom: 2px;
    }
    .toast-message {
      font-size: 13px;
      color: var(--text-secondary);
    }
    .toast-close {
      cursor: pointer;
      padding: 3px;
      margin-left: 10px;
      opacity: 0.6;
      transition: opacity 0.2s;
    }
    .toast-close:hover {
      opacity: 1;
    }
    @keyframes toast-in {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    .toast.removing {
      animation: toast-out 0.3s ease forwards;
    }
    @keyframes toast-out {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }

    /* === RESPONSIVE BREAKPOINTS === */

    /* Desktop Large (>1400px) - Full experience */
    @media (min-width: 1401px) {
      :root {
        --sidebar-width: 260px;
        --right-panel-width: 340px;
      }
    }

    /* Desktop Standard (1200-1400px) - Slightly compressed */
    @media (max-width: 1400px) and (min-width: 1201px) {
      :root {
        --sidebar-width: 220px;
        --right-panel-width: 300px;
      }

      .execution-bar {
        padding: 0 16px;
        gap: 16px;
      }

      .trade-button {
        min-width: 100px;
        padding: 10px 16px;
      }
    }

    /* Tablet Landscape (992-1200px) - Collapsible panels */
    @media (max-width: 1200px) and (min-width: 993px) {
      :root {
        --sidebar-width: 200px;
        --right-panel-width: 280px;
      }

      .platform-container {
        grid-template-columns: var(--sidebar-width) 1fr 0;
      }

      .left-sidebar {
        position: fixed;
        left: 0;
        top: var(--header-height);
        height: calc(100vh - var(--header-height) - var(--execution-bar-height));
        z-index: 100;
        transform: translateX(-100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .left-sidebar.open {
        transform: translateX(0);
        box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
      }

      .right-panels {
        position: fixed;
        right: 0;
        top: var(--header-height);
        height: calc(100vh - var(--header-height) - var(--execution-bar-height));
        width: var(--right-panel-width);
        z-index: 100;
        transform: translateX(100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .right-panels.open {
        transform: translateX(0);
        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
      }

      .sidebar-toggle,
      .panels-toggle {
        display: flex;
      }

      .chart-header {
        padding: 0 12px;
      }

      .execution-bar {
        padding: 0 12px;
        gap: 12px;
      }
    }

    /* Tablet Portrait (768-992px) - Stacked layout */
    @media (max-width: 992px) and (min-width: 769px) {
      :root {
        --header-height: 48px;
        --execution-bar-height: 56px;
        --sidebar-width: 240px;
        --right-panel-width: 280px;
      }

      .platform-container {
        grid-template-columns: 1fr;
        grid-template-rows: 1fr var(--execution-bar-height);
        grid-template-areas:
          "chart"
          "execution";
      }

      .left-sidebar,
      .right-panels {
        position: fixed;
        top: var(--header-height);
        height: calc(100vh - var(--header-height) - var(--execution-bar-height));
        z-index: 100;
        transform: translateX(-100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .left-sidebar { left: 0; }
      .right-panels {
        right: 0;
        left: auto;
        transform: translateX(100%);
      }

      .left-sidebar.open,
      .right-panels.open {
        transform: translateX(0);
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.4);
      }

      .chart-symbol-display .symbol {
        font-size: 14px;
      }

      .chart-symbol-display .current-price {
        font-size: 16px;
      }

      .timeframe-controls {
        bottom: 12px;
        padding: 4px 8px;
      }

      .timeframe-button {
        padding: 5px 10px;
        font-size: 11px;
      }

      .execution-bar {
        padding: 0 10px;
        gap: 10px;
      }

      .trade-header {
        min-width: 150px;
      }

      .symbol-info .symbol {
        font-size: 15px;
      }

      .symbol-info .price {
        font-size: 17px;
      }

      .trade-button {
        min-width: 90px;
        padding: 8px 12px;
        font-size: 12px;
      }
    }

    /* Mobile (< 768px) - Full mobile optimization */
    @media (max-width: 768px) {
      :root {
        --header-height: 44px;
        --execution-bar-height: 52px;
        --sidebar-width: 100vw;
        --right-panel-width: 100vw;
      }

      .header-main {
        padding: 0 10px;
      }

      .logo {
        font-size: 14px;
      }

      .logo-icon {
        font-size: 20px;
      }

      .search-bar {
        display: none;
      }

      .user-controls {
        gap: 8px;
      }

      .header-btn {
        width: 32px;
        height: 32px;
        font-size: 14px;
      }

      .platform-container {
        grid-template-columns: 1fr;
        grid-template-rows: 1fr var(--execution-bar-height);
        grid-template-areas:
          "chart"
          "execution";
      }

      .left-sidebar,
      .right-panels {
        position: fixed;
        top: var(--header-height);
        left: 0;
        width: 100%;
        height: calc(100vh - var(--header-height));
        z-index: 200;
        transform: translateY(100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .left-sidebar.open,
      .right-panels.open {
        transform: translateY(0);
      }

      .chart-header {
        height: 40px;
        padding: 0 10px;
      }

      .chart-symbol-display .symbol {
        font-size: 13px;
      }

      .chart-symbol-display .current-price {
        font-size: 15px;
      }

      .chart-symbol-display .price-change {
        font-size: 11px;
        padding: 1px 4px;
      }

      .toolbar-group {
        padding: 3px;
        gap: 2px;
      }

      .control-button {
        padding: 5px 8px;
        font-size: 11px;
      }

      .timeframe-controls {
        bottom: 10px;
        padding: 4px 6px;
        gap: 2px;
      }

      .timeframe-button {
        padding: 4px 8px;
        font-size: 10px;
      }

      .execution-bar {
        padding: 0 8px;
        gap: 8px;
        flex-wrap: wrap;
        height: auto;
        min-height: var(--execution-bar-height);
        padding: 6px 8px;
      }

      .trade-header {
        min-width: auto;
        flex: 1;
      }

      .symbol-info {
        flex-direction: column;
        align-items: flex-start;
        gap: 2px;
      }

      .symbol-info .symbol {
        font-size: 13px;
      }

      .symbol-info .price {
        font-size: 15px;
      }

      .position-sizer {
        flex-direction: row;
        gap: 6px;
      }

      .position-sizer .sizer-input {
        width: 60px;
        height: 32px;
        font-size: 12px;
      }

      .trade-buttons {
        gap: 6px;
      }

      .trade-button {
        min-width: 70px;
        padding: 8px 10px;
        font-size: 11px;
      }

      .emergency-stop {
        padding: 8px 12px;
        font-size: 11px;
      }

      /* Mobile signal cards */
      .signal-card {
        padding: 12px;
        margin-bottom: 10px;
      }

      .signal-card-metrics {
        grid-template-columns: repeat(2, 1fr);
      }

      /* Mobile portfolio */
      .portfolio-value .amount {
        font-size: 20px;
      }

      .risk-metrics {
        grid-template-columns: 1fr;
      }

      .var-display .var-value {
        font-size: 18px;
      }

      /* Mobile toast */
      .toast-container {
        bottom: calc(var(--execution-bar-height) + 10px);
        right: 10px;
        left: 10px;
        max-width: none;
      }
    }

    /* Small Mobile (< 480px) */
    @media (max-width: 480px) {
      :root {
        --execution-bar-height: 48px;
      }

      .execution-bar {
        justify-content: center;
      }

      .trade-header {
        display: none;
      }

      .position-sizer {
        flex: 1;
      }

      .trade-button {
        min-width: 60px;
        padding: 6px 8px;
      }

      .emergency-stop {
        padding: 6px 10px;
      }
    }

    /* === ANIMATION OPTIMIZATION (60fps) === */
    .left-sidebar,
    .right-panels,
    .execution-bar,
    .chart-header,
    .signal-card,
    .trade-button,
    .position-item {
      will-change: transform, opacity;
    }

    /* Reduce motion for accessibility */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }

      .signal-grade.grade-a-plus,
      .signal-grade.grade-a {
        animation: none;
      }
    }

    /* High contrast mode support */
    @media (prefers-contrast: high) {
      :root {
        --border-color: #4a4a6a;
        --glass-border: rgba(255, 255, 255, 0.3);
      }

      .trade-button,
      .signal-grade,
      .control-button.active {
        border: 2px solid currentColor;
      }
    }
  </style>
</head>
<body>
  <!-- Authentication Modal -->
  <div class="auth-modal" id="auth-modal">
    <div class="auth-container">
      <div class="auth-header">
        <div class="logo" style="justify-content: center;">
          <div class="logo-icon"></div>
          Moon<span>AI</span> Trading
        </div>
        <p>Access your AI-powered trading dashboard</p>
      </div>

      <div class="auth-tabs">
        <div class="auth-tab active" data-tab="login">Log In</div>
        <div class="auth-tab" data-tab="signup">Sign Up</div>
      </div>

      <div class="auth-form-container">
        <form class="auth-form" id="login-form">
          <div class="form-group">
            <label for="login-email">Email</label>
            <input type="email" id="login-email" placeholder="you@email.com" required />
          </div>
          <div class="form-group">
            <label for="login-password">Password</label>
            <input type="password" id="login-password" placeholder="Your password" required />
          </div>
          <button type="submit" class="auth-button">Log In</button>
          <div class="auth-message" id="login-message"></div>
        </form>

        <form class="auth-form" id="signup-form" style="display: none;">
          <div class="form-group">
            <label for="signup-email">Email</label>
            <input type="email" id="signup-email" placeholder="you@email.com" required />
          </div>
          <div class="form-group">
            <label for="signup-password">Password</label>
            <input type="password" id="signup-password" placeholder="Choose a strong password" required />
          </div>
          <button type="submit" class="auth-button">Create Account</button>
          <div class="auth-message" id="signup-message"></div>
        </form>
      </div>
    </div>
  </div>

  <header class="platform-header">
    <div class="logo">
      <div class="logo-icon"></div>
      Moon<span>AI</span> Trading
    </div>
    <div class="search-bar">
      <input type="text" placeholder="Search for assets, indicators or patterns..." />
    </div>
    <div class="user-controls">
      <button id="login-button" class="platform-button">Log In</button>
      <button id="watchlist-button" class="platform-button secondary">Watchlists</button>
      <div class="user-profile" id="user-profile" style="display: none;">
        <div class="user-avatar">A</div>
      </div>
    </div>
  </header>

  <div class="platform-container tv-layout" id="platform-container">
    <!-- Left Sidebar (Watchlist) -->
    <aside class="left-sidebar tv-left-panel" id="left-sidebar">
      <div id="watchlist-container">
        <!-- Watchlist items will be populated here -->
        <div class="stock-item">
          <div class="stock-info">
            <div class="stock-symbol">AAPL</div>
            <div class="stock-company">Apple Inc.</div>
          </div>
          <div class="stock-price-info">
            <div class="stock-price">$173.45</div>
            <div class="stock-change positive">+1.2%</div>
          </div>
        </div>
        <div class="stock-item active">
          <div class="stock-info">
            <div class="stock-symbol">MSFT</div>
            <div class="stock-company">Microsoft Corp.</div>
          </div>
          <div class="stock-price-info">
            <div class="stock-price">$312.79</div>
            <div class="stock-change positive">+0.8%</div>
          </div>
        </div>
        <div class="stock-item">
          <div class="stock-info">
            <div class="stock-symbol">TSLA</div>
            <div class="stock-company">Tesla, Inc.</div>
          </div>
          <div class="stock-price-info">
            <div class="stock-price">$194.05</div>
            <div class="stock-change negative">-1.3%</div>
          </div>
        </div>
        <div class="stock-item">
          <div class="stock-info">
            <div class="stock-symbol">NVDA</div>
            <div class="stock-company">NVIDIA Corp.</div>
          </div>
          <div class="stock-price-info">
            <div class="stock-price">$435.20</div>
            <div class="stock-change positive">+2.7%</div>
          </div>
        </div>
        <div class="stock-item">
          <div class="stock-info">
            <div class="stock-symbol">AMZN</div>
            <div class="stock-company">Amazon.com Inc.</div>
          </div>
          <div class="stock-price-info">
            <div class="stock-price">$128.91</div>
            <div class="stock-change negative">-0.4%</div>
          </div>
        </div>
        <div class="stock-item">
          <div class="stock-info">
            <div class="stock-symbol">GOOGL</div>
            <div class="stock-company">Alphabet Inc.</div>
          </div>
          <div class="stock-price-info">
            <div class="stock-price">$142.10</div>
            <div class="stock-change positive">+0.5%</div>
          </div>
        </div>
      </div>
    </aside>
    <div class="sidebar-toggle tv-panel-toggle left" id="sidebar-toggle" data-panel="left">
      <span></span>
    </div>

    <!-- Main Chart Area -->
    <main class="chart-area tv-chart-area">
      <!-- Enhanced Chart Header -->
      <div class="chart-header">
        <div class="chart-symbol-display">
          <span class="symbol">MSFT</span>
          <div class="price-display">
            <span class="current-price" id="chart-price">312.79</span>
            <span class="price-change up" id="chart-change">+2.48 (+0.80%)</span>
          </div>
        </div>
        <div class="chart-toolbar">
          <div class="chart-type-selector">
            <button class="chart-type-btn" data-type="line" title="Line Chart"></button>
            <button class="chart-type-btn active" data-type="candle" title="Candlestick"></button>
            <button class="chart-type-btn" data-type="area" title="Area Chart"></button>
          </div>
          <div class="toolbar-separator"></div>
          <div class="toolbar-group">
            <button class="control-button active" id="view-toggle-btn" data-tooltip="Switch between 2D and 3D chart views">
              <span class="icon"></span> 3D
            </button>
            <button class="control-button" id="indicator-btn" data-tooltip="Add technical indicators">
              <span class="icon"></span> Indicators
            </button>
            <button class="control-button" id="comparison-btn" data-tooltip="Compare with other assets">
              <span class="icon"></span> Compare
            </button>
          </div>
          <div class="toolbar-separator"></div>
          <div class="toolbar-group">
            <button class="control-button" id="time-warp-btn" data-tooltip="Visualize historical trends">Time-Warp</button>
            <button class="control-button" id="lens-btn" data-tooltip="Toggle gravitational lens effect">Lens</button>
          </div>
        </div>
      </div>

      <div class="chart-wrapper">
        <!-- Loading overlay for the chart specifically -->
        <div class="chart-loading" id="chart-loading">
          <div class="loader"></div>
          <div style="margin-top: 15px; color: var(--text-color);">
            Loading market data...
          </div>
        </div>
        
        <!-- Main chart container -->
        <div id="chart-container" style="width: 100%; height: 100%;"></div>

        <!-- 2D Chart container (Lightweight Charts) -->
        <div id="chart-2d-container" style="width: 100%; height: 100%; display: none;"></div>

        <!-- TradingView-style Context Menu -->
        <div id="chart-context-menu" class="chart-context-menu">
          <div class="context-menu-item" data-action="auto-scale">
            <span><span class="checkmark"></span>Auto (fits data to screen)</span>
          </div>
          <div class="context-menu-item" data-action="lock-ratio">
            <span>Lock price to bar ratio</span>
            <span class="shortcut">0.0008</span>
          </div>
          <div class="context-menu-item active" data-action="scale-chart-only">
            <span><span class="checkmark"></span>Scale price chart only</span>
          </div>
          <div class="context-menu-item" data-action="invert-scale">
            <span>Invert scale</span>
            <span class="shortcut"> I</span>
          </div>
          <div class="context-menu-divider"></div>
          <div class="context-menu-item active" data-action="regular-scale">
            <span><span class="checkmark"></span>Regular</span>
          </div>
          <div class="context-menu-item" data-action="percent-scale">
            <span>Percent</span>
            <span class="shortcut"> P</span>
          </div>
          <div class="context-menu-item" data-action="indexed-scale">
            <span>Indexed to 100</span>
          </div>
          <div class="context-menu-item" data-action="logarithmic-scale">
            <span>Logarithmic</span>
            <span class="shortcut"> L</span>
          </div>
          <div class="context-menu-divider"></div>
          <div class="context-menu-item" data-action="move-left">
            <span>Move scale to left</span>
          </div>
          <div class="context-menu-divider"></div>
          <div class="context-menu-item submenu">
            <span>Labels</span>
          </div>
          <div class="context-menu-item submenu">
            <span>Lines</span>
          </div>
          <div class="context-menu-item active" data-action="plus-button">
            <span><span class="checkmark"></span>Plus button</span>
          </div>
          <div class="context-menu-divider"></div>
          <div class="context-menu-item" data-action="more-settings">
            <span> More settings...</span>
          </div>
        </div>
      </div>

      <!-- Timeframe Controls -->
      <div class="timeframe-controls">
        <div class="timeframe-button" data-timeframe="1d">1D</div>
        <div class="timeframe-button active" data-timeframe="1w">1W</div>
        <div class="timeframe-button" data-timeframe="1m">1M</div>
        <div class="timeframe-button" data-timeframe="3m">3M</div>
        <div class="timeframe-button" data-timeframe="1y">1Y</div>
        <div class="timeframe-button" data-timeframe="all">ALL</div>
      </div>
    </main>

    <!-- Right Panels: Portfolio, Signals, AI, Sentiment, News -->
    <aside class="right-panels tv-right-panel" id="right-panels">
      <!-- Portfolio Panel with VaR -->
      <div class="portfolio-panel tv-portfolio" id="portfolio-panel">
        <div class="portfolio-header tv-panel-header">
          <h3>Portfolio</h3>
          <div class="tv-panel-controls">
            <span class="tv-panel-status live">LIVE</span>
            <button class="tv-panel-collapse" data-panel="portfolio" title="Collapse"></button>
          </div>
        </div>
        <div class="portfolio-value tv-portfolio-value">
          <div class="label">Total Value</div>
          <div class="amount" id="portfolio-value">$124,847.50</div>
          <div class="daily-change positive" id="portfolio-change">+$2,341.25 (+1.91%)</div>
        </div>
        <div class="risk-metrics tv-metrics-grid">
          <div class="risk-metric tv-metric" data-metric="win-rate">
            <div class="label">Win Rate <span class="info-icon tv-tooltip" data-tooltip="Win rate over last 30 trades"></span></div>
            <div class="value success" id="win-rate">68.4%</div>
          </div>
          <div class="risk-metric tv-metric" data-metric="sharpe">
            <div class="label">Sharpe Ratio <span class="info-icon tv-tooltip" data-tooltip="Risk-adjusted return"></span></div>
            <div class="value" id="sharpe-ratio">1.87</div>
          </div>
          <div class="risk-metric tv-metric" data-metric="max-dd">
            <div class="label">Max DD <span class="info-icon tv-tooltip" data-tooltip="Maximum Drawdown"></span></div>
            <div class="value warning" id="max-dd">-8.2%</div>
          </div>
          <div class="risk-metric tv-metric" data-metric="profit-factor">
            <div class="label">Profit Factor</div>
            <div class="value" id="profit-factor">2.14</div>
          </div>
        </div>
        <div class="var-display tv-var-display">
          <div class="var-header">
            <span class="var-label">Value at Risk (VaR)</span>
            <span class="var-confidence tv-badge">95% CI</span>
          </div>
          <div class="var-values">
            <span class="var-value tv-var-value" id="var-value">-$3,745</span>
            <span class="var-percentage">(-3.0%)</span>
          </div>
        </div>
        <div class="position-list tv-positions-list">
          <div class="position-list-header">
            <h4 class="positions-count">Open Positions (3)</h4>
          </div>
          <div class="positions-items">
            <!-- Positions rendered dynamically by PortfolioController -->
          </div>
        </div>
      </div>

      <!-- Watchlist Panel -->
      <div class="panel tv-watchlist-panel" id="watchlist-panel" data-panel="watchlist" style="display: none;">
        <div class="panel-header tv-panel-header">
          <div class="panel-header-left">
            <h3>Watchlist</h3>
          </div>
          <div class="panel-header-controls">
            <div class="panel-link-indicator" data-panel="watchlist" title="Link Group">
              <span class="panel-link-dot blue"></span>
            </div>
            <button class="panel-detach-btn" data-panel="watchlist" title="Detach to new window">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              </svg>
            </button>
          </div>
        </div>
        <div class="panel-content watchlist-list tv-watchlist-list" id="watchlist-content">
          <div class="watchlist-search">
            <input type="text" placeholder="Search symbols..." class="watchlist-search-input" />
          </div>
          <div class="watchlist-items">
            <!-- Watchlist items rendered dynamically -->
          </div>
        </div>
      </div>

      <!-- Alerts Panel -->
      <div class="panel tv-alerts-panel" id="alerts-panel" data-panel="alerts" style="display: none;">
        <div class="panel-header tv-panel-header">
          <div class="panel-header-left">
            <h3>Alerts</h3>
            <span class="tv-badge">1 active</span>
          </div>
          <div class="panel-header-controls">
            <div class="panel-link-indicator" data-panel="alerts" title="Link Group">
              <span class="panel-link-dot blue"></span>
            </div>
            <button class="panel-detach-btn" data-panel="alerts" title="Detach to new window">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              </svg>
            </button>
          </div>
        </div>
        <div class="panel-content alerts-list tv-alerts-list" id="alerts-content">
          <!-- Alerts rendered dynamically -->
        </div>
      </div>

      <!-- AI Signals Panel with Grading -->
      <div class="panel tv-signals-panel" id="signals-panel" data-panel="signals">
        <div class="panel-header tv-panel-header">
          <div class="panel-header-left">
            <h3>AI Signals</h3>
          </div>
          <div class="panel-header-controls">
            <div class="signal-filters">
              <button class="signal-filter-btn active" data-filter="all">All</button>
              <button class="signal-filter-btn" data-filter="buy">Buy</button>
              <button class="signal-filter-btn" data-filter="sell">Sell</button>
            </div>
            <label class="auto-trade-toggle tv-toggle">
              <input type="checkbox" id="auto-trade-toggle">
              <span class="tv-toggle-slider"></span>
              <span class="tv-toggle-label">Auto</span>
            </label>
            <span class="signals-count tv-badge">3 pending</span>
            <div class="panel-link-indicator" data-panel="signals" title="Link Group">
              <span class="panel-link-dot blue"></span>
            </div>
            <button class="panel-detach-btn" data-panel="signals" title="Detach to new window">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              </svg>
            </button>
            <button class="clear-signals-btn tv-btn-icon" id="clear-signals" title="Clear all signals"></button>
          </div>
        </div>
        <div class="panel-content signals-list tv-signals-list" id="signals-content">
          <!-- Signals rendered dynamically by SignalsController -->
        </div>
      </div>

      <!-- AI Combined Panel (Predictions + Assistant) -->
      <div class="panel tv-ai-panel" id="ai-combined-panel" data-panel="ai" style="display: none;">
        <div class="panel-header tv-panel-header">
          <div class="panel-header-left">
            <h3>AI Assistant</h3>
          </div>
          <div class="panel-header-controls">
            <div class="ai-tabs">
              <button class="ai-tab-btn active" data-tab="predictions">Predictions</button>
              <button class="ai-tab-btn" data-tab="assistant">Chat</button>
            </div>
            <div class="panel-link-indicator" data-panel="ai" title="Link Group">
              <span class="panel-link-dot blue"></span>
            </div>
            <button class="panel-detach-btn" data-panel="ai" title="Detach to new window">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              </svg>
            </button>
            <div id="ai-refresh" style="cursor: pointer; font-size: 14px;"></div>
          </div>
        </div>
        <div class="panel-content ai-combined-content" id="ai-combined-content">
          <!-- Tab: Predictions -->
          <div class="ai-tab-content active" data-tab="predictions" id="ai-content">
            <div class="skeleton skeleton-heading"></div>
            <div class="skeleton skeleton-text"></div>
            <div class="skeleton skeleton-text"></div>
            <div class="skeleton skeleton-text-short"></div>
          </div>
          <!-- Tab: Assistant Chat -->
          <div class="ai-tab-content" data-tab="assistant" style="display: none;">
            <div class="ai-chat-messages" id="ai-chat-messages">
              <div class="ai-message assistant">How can I help with your trading today?</div>
            </div>
            <div class="ai-chat-input">
              <input type="text" id="ai-chat-input" placeholder="Ask about markets, signals, or strategies..." />
              <button class="ai-chat-send" id="ai-chat-send">Send</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Screener Panel -->
      <div class="panel tv-screener-panel" id="screener-panel" data-panel="screener" style="display: none;">
        <div class="panel-header tv-panel-header">
          <div class="panel-header-left">
            <h3>Screener</h3>
          </div>
          <div class="panel-header-controls">
            <div class="screener-tabs">
              <button class="screener-tab-btn active" data-tab="stocks">Stocks</button>
              <button class="screener-tab-btn" data-tab="crypto">Crypto</button>
              <button class="screener-tab-btn" data-tab="custom">Custom</button>
            </div>
            <div class="panel-link-indicator" data-panel="screener" title="Link Group">
              <span class="panel-link-dot blue"></span>
            </div>
            <button class="panel-detach-btn" data-panel="screener" title="Detach to new window">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              </svg>
            </button>
          </div>
        </div>
        <div class="panel-content screener-content" id="screener-content">
          <!-- Screener content rendered dynamically -->
          <div class="screener-filters">
            <select class="screener-filter-select">
              <option value="">Add Filter...</option>
              <option value="rsi">RSI</option>
              <option value="macd">MACD</option>
              <option value="sma">SMA</option>
              <option value="volume">Volume</option>
              <option value="price">Price</option>
            </select>
          </div>
          <div class="screener-results">
            <div class="screener-loading">Loading results...</div>
          </div>
        </div>
      </div>

      <!-- Pine Script Panel -->
      <div class="panel tv-pine-panel" id="pine-panel" data-panel="pine" style="display: none;">
        <div class="panel-header tv-panel-header">
          <div class="panel-header-left">
            <h3>Pine Script</h3>
          </div>
          <div class="panel-header-controls">
            <button class="pine-action-btn" id="pine-new" title="New Script">New</button>
            <button class="pine-action-btn" id="pine-save" title="Save Script">Save</button>
            <div class="panel-link-indicator" data-panel="pine" title="Link Group">
              <span class="panel-link-dot blue"></span>
            </div>
            <button class="panel-detach-btn" data-panel="pine" title="Detach to new window">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              </svg>
            </button>
          </div>
        </div>
        <div class="panel-content pine-content" id="pine-content">
          <textarea class="pine-editor" id="pine-editor" placeholder="//@version=5
indicator(&quot;My Indicator&quot;, overlay=true)

// Your Pine Script code here
plot(close)"></textarea>
          <div class="pine-actions">
            <button class="pine-run-btn" id="pine-run">Run Script</button>
            <button class="pine-apply-btn" id="pine-apply">Apply to Chart</button>
          </div>
        </div>
      </div>

      <!-- Calendar Panel -->
      <div class="panel tv-calendar-panel" id="calendar-panel" data-panel="calendar" style="display: none;">
        <div class="panel-header tv-panel-header">
          <div class="panel-header-left">
            <h3>Economic Calendar</h3>
          </div>
          <div class="panel-header-controls">
            <div class="calendar-filters">
              <button class="calendar-filter-btn active" data-filter="all">All</button>
              <button class="calendar-filter-btn" data-filter="high">High Impact</button>
            </div>
            <div class="panel-link-indicator" data-panel="calendar" title="Link Group">
              <span class="panel-link-dot blue"></span>
            </div>
            <button class="panel-detach-btn" data-panel="calendar" title="Detach to new window">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              </svg>
            </button>
          </div>
        </div>
        <div class="panel-content calendar-content" id="calendar-content">
          <!-- Calendar events rendered dynamically -->
          <div class="calendar-loading">Loading calendar...</div>
        </div>
      </div>

      <!-- News & Sentiment Panel -->
      <div class="panel tv-news-panel" id="news-panel" data-panel="news" style="display: none;">
        <div class="panel-header tv-panel-header">
          <div class="panel-header-left">
            <h3>News & Sentiment</h3>
          </div>
          <div class="panel-header-controls">
            <div class="news-tabs">
              <button class="news-tab-btn active" data-tab="news">News</button>
              <button class="news-tab-btn" data-tab="sentiment">Sentiment</button>
            </div>
            <div class="panel-link-indicator" data-panel="news" title="Link Group">
              <span class="panel-link-dot blue"></span>
            </div>
            <button class="panel-detach-btn" data-panel="news" title="Detach to new window">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              </svg>
            </button>
            <div id="news-refresh" style="cursor: pointer; font-size: 14px;"></div>
          </div>
        </div>
        <div class="panel-content news-combined-content" id="news-combined-content">
          <!-- Tab: News -->
          <div class="news-tab-content active" data-tab="news" id="news-content">
            <div class="skeleton skeleton-heading"></div>
            <div class="skeleton skeleton-text"></div>
            <div class="skeleton skeleton-text"></div>
            <div class="skeleton skeleton-text-short"></div>
          </div>
          <!-- Tab: Sentiment -->
          <div class="news-tab-content" data-tab="sentiment" id="sentiment-content" style="display: none;">
            <div class="skeleton skeleton-heading"></div>
            <div class="skeleton skeleton-text"></div>
            <div class="skeleton skeleton-text"></div>
            <div class="skeleton skeleton-text-short"></div>
          </div>
        </div>
      </div>

      <!-- Notifications Panel -->
      <div class="panel tv-notifications-panel" id="notifications-panel" data-panel="notifications" style="display: none;">
        <div class="panel-header tv-panel-header">
          <div class="panel-header-left">
            <h3>Notifications</h3>
            <span class="tv-badge">3 new</span>
          </div>
          <div class="panel-header-controls">
            <button class="mark-all-read-btn" id="mark-all-read" title="Mark all as read">Mark all read</button>
            <button class="panel-detach-btn" data-panel="notifications" title="Detach to new window">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
              </svg>
            </button>
          </div>
        </div>
        <div class="panel-content notifications-content" id="notifications-content">
          <!-- Notifications rendered dynamically -->
          <div class="notification-item unread">
            <div class="notification-icon"></div>
            <div class="notification-text">
              <div class="notification-title">AAPL Alert Triggered</div>
              <div class="notification-desc">Price crossed above $185.00</div>
              <div class="notification-time">2 minutes ago</div>
            </div>
          </div>
          <div class="notification-item unread">
            <div class="notification-icon"></div>
            <div class="notification-text">
              <div class="notification-title">New AI Signal: NVDA</div>
              <div class="notification-desc">Buy signal with A+ grade</div>
              <div class="notification-time">5 minutes ago</div>
            </div>
          </div>
          <div class="notification-item unread">
            <div class="notification-icon"></div>
            <div class="notification-text">
              <div class="notification-title">Screener Match</div>
              <div class="notification-desc">3 stocks match your custom filter</div>
              <div class="notification-time">10 minutes ago</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Settings Panel -->
      <div class="panel tv-settings-panel" id="settings-panel" data-panel="settings" style="display: none;">
        <div class="panel-header tv-panel-header">
          <div class="panel-header-left">
            <h3>Settings</h3>
          </div>
          <div class="panel-header-controls">
            <!-- Settings not detachable -->
          </div>
        </div>
        <div class="panel-content settings-content" id="settings-content">
          <div class="settings-section">
            <h4>Appearance</h4>
            <div class="setting-item">
              <label>Theme</label>
              <select class="setting-select" id="theme-select">
                <option value="dark">Dark</option>
                <option value="light">Light</option>
                <option value="system">System</option>
              </select>
            </div>
          </div>
          <div class="settings-section">
            <h4>Notifications</h4>
            <div class="setting-item">
              <label>Sound Alerts</label>
              <label class="tv-toggle">
                <input type="checkbox" id="sound-alerts-toggle" checked>
                <span class="tv-toggle-slider"></span>
              </label>
            </div>
            <div class="setting-item">
              <label>Desktop Notifications</label>
              <label class="tv-toggle">
                <input type="checkbox" id="desktop-notifications-toggle" checked>
                <span class="tv-toggle-slider"></span>
              </label>
            </div>
          </div>
          <div class="settings-section">
            <h4>Trading</h4>
            <div class="setting-item">
              <label>Confirm Orders</label>
              <label class="tv-toggle">
                <input type="checkbox" id="confirm-orders-toggle" checked>
                <span class="tv-toggle-slider"></span>
              </label>
            </div>
          </div>
        </div>
      </div>

      <!-- Help Panel -->
      <div class="panel tv-help-panel" id="help-panel" data-panel="help" style="display: none;">
        <div class="panel-header tv-panel-header">
          <div class="panel-header-left">
            <h3>Help Center</h3>
          </div>
          <div class="panel-header-controls">
            <!-- Help not detachable -->
          </div>
        </div>
        <div class="panel-content help-content" id="help-content">
          <div class="help-section">
            <h4>Keyboard Shortcuts</h4>
            <div class="shortcut-item">
              <span class="shortcut-key">Ctrl + \</span>
              <span class="shortcut-desc">Toggle sidebar</span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-key">Alt + 1-9</span>
              <span class="shortcut-desc">Quick panel access</span>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-key">Ctrl + Shift + D</span>
              <span class="shortcut-desc">Detach current panel</span>
            </div>
          </div>
          <div class="help-section">
            <h4>Quick Links</h4>
            <a href="#" class="help-link">Documentation</a>
            <a href="#" class="help-link">Video Tutorials</a>
            <a href="#" class="help-link">Contact Support</a>
          </div>
        </div>
      </div>
    </aside>
    <!-- TradingView-Style Widgetbar Hider (Panel Toggle) -->
    <div class="panels-toggle tv-panel-toggle right widgetbar-hider" id="panels-toggle" data-panel="right" role="button" aria-label="Toggle right panel" aria-expanded="true" tabindex="0">
      <div class="hider-inner apply-common-tooltip common-tooltip-vertical common-tooltip-otl">
        <svg xmlns="http://www.w3.org/2000/svg" width="9" height="27" viewBox="0 0 9 27" class="hider-svg">
          <g fill="none" fill-rule="evenodd">
            <path class="background-pill" d="M4.5.5a4 4 0 0 1 4 4v18a4 4 0 1 1-8 0v-18a4 4 0 0 1 4-4z"></path>
            <path class="arrow-icon" d="M5.5 10l-2 3.5 2 3.5"></path>
          </g>
        </svg>
      </div>
      <span class="tv-tooltip">Hide panel</span>
    </div>

    <!-- TradingView-Style Right Widgetbar Toolbar -->
    <div class="tv-widgetbar" id="widgetbar" role="toolbar" aria-label="Right toolbar" aria-orientation="vertical">
      <div class="tv-widgetbar-tabs">
        <div class="tv-widgetbar-scroll">
          <div class="tv-widgetbar-content">
            <div class="tv-widgetbar-toolbar" data-name="right-toolbar">
              <!-- Watchlist Button -->
              <button
                aria-label="Watchlist, details and news"
                aria-pressed="false"
                type="button"
                class="tv-widgetbar-btn"
                data-name="base"
                data-tooltip="Watchlist"
                data-panel="watchlist"
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" width="44" height="44">
                  <path fill="currentColor" d="M28 16H16v1h12v-1ZM28 20H16v1h12v-1ZM16 24h12v1H16v-1Z"></path>
                  <path fill="currentColor" fill-rule="evenodd" d="m22 30-10 4V12a1 1 0 0 1 1-1h18a1 1 0 0 1 1 1v22l-10-4Zm-9 2.52V12h18v20.52l-9-3.6-9 3.6Z"></path>
                </svg>
                <span class="tv-tooltip">Watchlist</span>
              </button>

              <!-- Alerts Button -->
              <button
                aria-label="Alerts"
                aria-pressed="false"
                type="button"
                class="tv-widgetbar-btn"
                data-name="alerts"
                data-tooltip="Alerts"
                data-panel="alerts"
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" width="44" height="44">
                  <path fill="currentColor" d="M35 14.66 29.16 9l-.7.72 5.84 5.66.7-.72ZM9 14.66 14.84 9l.7.72-5.84 5.66-.7-.72ZM22 16v7h-5v1h6v-8h-1Z"></path>
                  <path fill="currentColor" fill-rule="evenodd" d="M22 33a11 11 0 1 0 0-22 11 11 0 0 0 0 22Zm0-1a10 10 0 1 0 0-20 10 10 0 0 0 0 20Z"></path>
                </svg>
                <div class="tv-counter-row">
                  <span class="tv-counter small color-danger" aria-label="1 unread alert">1</span>
                </div>
                <span class="tv-tooltip">Alerts</span>
              </button>

              <!-- Object Tree / Signals Button -->
              <button
                aria-label="Object Tree and Signals"
                aria-pressed="true"
                type="button"
                class="tv-widgetbar-btn active"
                data-name="object_tree"
                data-tooltip="Signals"
                data-panel="signals"
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" width="44" height="44">
                  <path fill="currentColor" d="M21.34 12.13a1 1 0 0 1 .98 0l10.41 5.93a1 1 0 0 1 0 1.73l-10.4 5.93a1 1 0 0 1-.99 0L10.78 19.8a1 1 0 0 1 0-1.75l10.56-5.92Zm.49.87-10.56 5.93 10.56 5.93 10.4-5.93L21.84 13ZM33.5 24.86l-11.66 6.8L10 25l.5-.87 11.33 6.38L32.99 24l.5.87Z"></path>
                </svg>
                <span class="tv-tooltip">Signals</span>
              </button>

              <!-- AI Chat Button -->
              <button
                aria-label="AI Assistant"
                aria-pressed="false"
                type="button"
                class="tv-widgetbar-btn"
                data-name="ai_chat"
                data-tooltip="AI Assistant"
                data-panel="ai"
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" width="44" height="44" fill="none">
                  <path fill="currentColor" fill-rule="evenodd" d="M11 14.5a2.5 2.5 0 0 1 2.5-2.5h13a2.5 2.5 0 0 1 2.5 2.5v9a2.5 2.5 0 0 1-2.5 2.5H14.3l-.15.15L11 29.29V14.5Zm2.5-3.5a3.5 3.5 0 0 0-3.5 3.5v17.2l.85-.85L14.71 27H19v.5a3.5 3.5 0 0 0 3.5 3.5H29.3l3.86 3.85.85.86V22.5a3.5 3.5 0 0 0-3.5-3.5H30v-4.5a3.5 3.5 0 0 0-3.5-3.5h-13ZM30 20v3.5a3.5 3.5 0 0 1-3.5 3.5H20v.5a2.5 2.5 0 0 0 2.5 2.5H29.7l.15.15L33 33.29V22.5a2.5 2.5 0 0 0-2.5-2.5H30Z"></path>
                </svg>
                <span class="tv-tooltip">AI Assistant</span>
              </button>

              <!-- Spacer/Filler -->
              <div class="tv-widgetbar-filler"></div>

              <!-- Screeners Button -->
              <button
                aria-label="Screeners"
                aria-pressed="false"
                type="button"
                class="tv-widgetbar-btn"
                data-name="screener"
                data-tooltip="Screeners"
                data-panel="screener"
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" width="44" height="44" fill="currentColor">
                  <g clip-path="url(#screener-a)">
                    <path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M22 8a14 14 0 1 0 0 28 14 14 0 0 0 0-28ZM9 22a13 13 0 0 1 22.03-9.35L27.5 16.2a8 8 0 1 0 .68.73l3.55-3.55A13 13 0 1 1 9 22Zm17.79-5.1a7 7 0 1 0 .68.74l-3.62 3.6A2 2 0 0 1 22 24a2 2 0 1 1 1.25-3.56l3.54-3.54Z"></path>
                  </g>
                  <defs>
                    <clipPath id="screener-a">
                      <path fill="currentColor" d="M0 0h44v44H0z"></path>
                    </clipPath>
                  </defs>
                </svg>
                <span class="tv-tooltip">Screeners</span>
              </button>

              <!-- Pine Script / Strategy Button -->
              <button
                aria-label="Pine Script"
                aria-pressed="false"
                type="button"
                class="tv-widgetbar-btn"
                data-name="pine"
                data-tooltip="Strategy Editor"
                data-panel="pine"
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" width="44" height="44">
                  <path fill="currentColor" d="M22.38 10.18a.5.5 0 0 0-.78.02l-9.5 12.5a.5.5 0 0 0 .57.77l6.85-2.4 5.72 4.81c.17.14.4.16.59.04l5.93-3.75a.5.5 0 0 0 .12-.74zm-8.47 11.8L22 11.3l8.73 10.33-5.14 3.25-5.65-4.76a.5.5 0 0 0-.5-.1z"></path>
                  <path fill="currentColor" d="M13.64 26 9.1 32.2a.5.5 0 0 0 .4.8h25a.5.5 0 0 0 .4-.8L30.36 26l-.8.59 3.95 5.4H10.5l3.96-5.4z"></path>
                </svg>
                <span class="tv-tooltip">Strategy Editor</span>
              </button>

              <!-- Calendar Button -->
              <button
                aria-label="Economic Calendar"
                aria-pressed="false"
                type="button"
                class="tv-widgetbar-btn"
                data-name="calendar"
                data-tooltip="Calendar"
                data-panel="calendar"
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" width="44" height="44">
                  <path fill="currentColor" fill-rule="evenodd" d="M15 11h2v4h-2v-4Zm-1 0a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v1h8v-1a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v1h1a3 3 0 0 1 3 3v16a3 3 0 0 1-3 3H13a3 3 0 0 1-3-3V15a3 3 0 0 1 3-3h1v-1Zm4 2h8v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2h1a2 2 0 0 1 2 2v4H11v-4c0-1.1.9-2 2-2h1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2Zm-7 7v11c0 1.1.9 2 2 2h18a2 2 0 0 0 2-2V20H11Zm18-9h-2v4h2v-4Z"></path>
                </svg>
                <span class="tv-tooltip">Calendar</span>
              </button>

              <!-- Community/News Button -->
              <button
                aria-label="News & Community"
                aria-pressed="false"
                type="button"
                class="tv-widgetbar-btn"
                data-name="community"
                data-tooltip="News"
                data-panel="news"
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" width="44" height="44">
                  <path fill="currentColor" d="M24.78 15.6a.9.9 0 0 1-1.31.96l-1.47-.8-1.47.8a.9.9 0 0 1-1.31-.96l.3-1.64-1.2-1.15a.9.9 0 0 1 .5-1.54l1.65-.22.72-1.51.07-.12a.9.9 0 0 1 1.55.12l.72 1.5 1.65.23a.9.9 0 0 1 .5 1.54l-1.2 1.15zm-1.3-1.51a.9.9 0 0 1 .27-.82l1.1-1.04-1.5-.2a.9.9 0 0 1-.7-.5L22 10.16l-.65 1.37a.9.9 0 0 1-.7.5l-1.5.2 1.1 1.04a.9.9 0 0 1 .27.82l-.28 1.49 1.33-.73.1-.04a1 1 0 0 1 .66 0l.1.04 1.33.73zm4.88 5.27a9 9 0 0 1-12.72 0l-.03-.03.63-.79.1.11a8 8 0 0 0 11.32 0l.12-.13.64.78zm3.86 4.6a15 15 0 0 1-20.4.04l.63-.78a14 14 0 0 0 19.14-.03zm3.8 4.66a21 21 0 0 1-28 .05l.64-.78a20 20 0 0 0 26.73-.04z"></path>
                </svg>
                <div class="tv-counter-row">
                  <span class="tv-counter small color-danger" aria-label="New updates">5</span>
                </div>
                <span class="tv-tooltip">News</span>
              </button>

              <!-- Notifications Button -->
              <button
                aria-label="Notifications"
                aria-pressed="false"
                type="button"
                class="tv-widgetbar-btn"
                data-name="notifications"
                data-tooltip="Notifications"
                data-panel="notifications"
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" width="44" height="44" fill="none">
                  <path fill="currentColor" d="M22 8a3.99 3.99 0 0 1 3.941 3.303A10 10 0 0 1 32 20.496v6.554a2.501 2.501 0 0 1-.5 4.95h-5.626a4.002 4.002 0 0 1-7.748 0H12.5a2.5 2.5 0 0 1-.5-4.95v-6.554c0-4.123 2.496-7.664 6.059-9.193A3.99 3.99 0 0 1 22 8m-2.83 24a3.001 3.001 0 0 0 5.66 0zm-6.67-4a1.5 1.5 0 0 0 0 3h19a1.5 1.5 0 0 0 0-3zM22 8.987a3 3 0 0 0-2.956 2.486L18.95 12l-.498.222A9 9 0 0 0 13 20.496V27h18v-6.504a9 9 0 0 0-5.453-8.274L25.049 12l-.093-.527A3 3 0 0 0 22 8.987"></path>
                </svg>
                <div class="tv-counter-row">
                  <span class="tv-counter small color-warning" aria-label="3 notifications">3</span>
                </div>
                <span class="tv-tooltip">Notifications</span>
              </button>

              <!-- Separator -->
              <div class="tv-widgetbar-separator"></div>

              <!-- Settings Button -->
              <button
                aria-label="Settings"
                aria-pressed="false"
                type="button"
                class="tv-widgetbar-btn"
                data-name="settings"
                data-tooltip="Settings"
                data-panel="settings"
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" width="44" height="44" fill="none">
                  <path fill="currentColor" d="M22 8c7.732 0 14 6.268 14 14s-6.268 14-14 14S8 29.732 8 22 14.268 8 22 8m-8 22a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1zm7 0a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1zm7 0a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1zm-14-7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1zm7 0a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1zm7 0a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1zm-14-7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1zm7 0a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1zm7 0a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1z"></path>
                </svg>
                <span class="tv-tooltip">Settings</span>
              </button>

              <!-- Help Button -->
              <button
                aria-label="Help Center"
                aria-pressed="false"
                type="button"
                class="tv-widgetbar-btn"
                data-name="help"
                data-tooltip="Help Center"
                data-panel="help"
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 44" width="44" height="44" fill="none">
                  <path fill="currentColor" d="M22 8c7.732 0 14 6.268 14 14s-6.268 14-14 14S8 29.732 8 22 14.268 8 22 8m0 1C14.82 9 9 14.82 9 22s5.82 13 13 13 13-5.82 13-13S29.18 9 22 9m.201 18.01A2.016 2.016 0 0 1 24 29l-.01.204A2.017 2.017 0 0 1 22 31l-.201-.01a2.02 2.02 0 0 1-1.788-1.785L20 29c0-1.104.917-2 2-2zM22 28c-.537 0-1 .455-1 1s.462 1 1 1 1-.455 1-1-.462-1-1-1m.31-15C24.9 13 27 15.1 27 17.69a4.31 4.31 0 0 1-2.195 3.754l-.872.492a2.81 2.81 0 0 0-1.433 2.45V25h-1v-.614c0-1.377.743-2.647 1.942-3.322l.872-.49A3.31 3.31 0 0 0 26 17.688 3.69 3.69 0 0 0 22.31 14H22a4 4 0 0 0-4 4h-1a5 5 0 0 1 5-5z"></path>
                </svg>
                <span class="tv-tooltip">Help Center</span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Execution Bar (1-Click Trading) -->
    <div class="execution-bar tv-execution-bar" id="execution-bar">
      <!-- Symbol + Live Price -->
      <div class="trade-header tv-trade-symbol">
        <div class="symbol-info">
          <span class="symbol" id="trade-symbol">MSFT</span>
          <span class="price live" id="trade-price">$312.79</span>
          <span class="change positive" id="trade-change">+0.8%</span>
        </div>
        <div class="live-pnl positive" id="live-pnl">+$1,247.50</div>
      </div>

      <!-- Position Sizer (Kelly Criterion) -->
      <div class="position-sizer tv-position-sizer">
        <div class="sizer-group">
          <label class="sizer-label">Shares</label>
          <input type="number" class="sizer-input tv-input" id="shares-input" name="shares" value="100" min="1" step="1">
        </div>
        <div class="sizer-group">
          <label class="sizer-label">$</label>
          <input type="number" class="sizer-input tv-input" id="dollar-input" name="dollar" value="31279" min="1" step="100">
        </div>
        <div class="sizer-group">
          <label class="sizer-label">Risk %</label>
          <input type="number" class="sizer-input tv-input" id="risk-input" name="risk" value="2" min="0.1" max="100" step="0.1">
        </div>
        <button class="kelly-btn tv-kelly-btn" id="kelly-btn" title="Calculate optimal position using Kelly Criterion">
          <span class="kelly-icon">K</span>
          Kelly
        </button>
      </div>

      <!-- Trade Buttons -->
      <div class="trade-buttons tv-trade-actions">
        <button class="trade-button buy tv-trade-btn" id="buy-btn">
          <span class="btn-icon"></span>
          BUY
        </button>
        <button class="trade-button sell tv-trade-btn" id="sell-btn">
          <span class="btn-icon"></span>
          SELL
        </button>
      </div>

      <!-- Emergency Stop -->
      <button class="emergency-stop tv-emergency-btn" id="emergency-stop">
        <span class="stop-icon"></span>
        CLOSE ALL
      </button>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading-overlay">
    <div class="loader-container">
      <div class="loader"></div>
      <div class="loading-message">Loading Moon AI Trading Platform</div>
      <div class="loading-progress">
        <div class="loading-progress-bar" id="loading-progress-bar"></div>
      </div>
      <div class="loading-tasks">
        <div class="loading-task">
          <div class="loading-task-status">
            <div class="loading-task-pending" id="task-initialize"></div>
          </div>
          <div>Initializing platform components</div>
        </div>
        <div class="loading-task">
          <div class="loading-task-status">
            <div class="loading-task-pending" id="task-connect"></div>
          </div>
          <div>Connecting to market data</div>
        </div>
        <div class="loading-task">
          <div class="loading-task-status">
            <div class="loading-task-pending" id="task-ai"></div>
          </div>
          <div>Loading AI prediction models</div>
        </div>
        <div class="loading-task">
          <div class="loading-task-status">
            <div class="loading-task-pending" id="task-chart"></div>
          </div>
          <div>Preparing 3D visualization</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Voice Assistant -->
  <div class="voice-assistant" id="voice-assistant">
    <div class="voice-assistant-icon" id="voice-assistant-icon">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
        <line x1="12" x2="12" y1="19" y2="22"></line>
      </svg>
    </div>
    <div class="voice-assistant-panel" id="voice-assistant-panel">
      <div class="voice-panel-header">
        <div>Moon AI Assistant</div>
        <div class="voice-panel-close" id="voice-panel-close"></div>
      </div>
      <div class="voice-panel-body" id="voice-panel-content">
        <div class="assistant-message">How can I help with your trading today?</div>
      </div>
      <div class="voice-panel-footer">
        <input type="text" id="voice-input" placeholder="Ask something or press mic..." />
        <button id="voice-mic-button">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
            <line x1="12" x2="12" y1="19" y2="22"></line>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- Custom Indicator Modal -->
  <div class="custom-indicator-modal" id="custom-indicator-modal">
    <div class="custom-indicator-container">
      <div class="modal-header">
        <h3>Custom Indicator Editor</h3>
        <div class="modal-close" id="indicator-modal-close"></div>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Name</label>
          <input type="text" id="indicator-name" placeholder="Indicator name" />
        </div>
        <div class="form-group">
          <label>Script</label>
          <textarea id="indicator-script" rows="8" placeholder="// Example:
function myIndicator(data) {
  // Calculate values
  const result = data.map(candle => ({
    price: candle.close,
    signal: candle.close > candle.open ? 'buy' : 'sell'
  }));
  return result;
}"></textarea>
        </div>
        <div class="form-group">
          <label>Settings</label>
          <div class="indicator-settings">
            <div class="setting">
              <label>Color</label>
              <input type="color" id="indicator-color" value="#6c5ce7" />
            </div>
            <div class="setting">
              <label>Line Width</label>
              <input type="range" id="indicator-width" min="1" max="5" value="2" />
            </div>
            <div class="setting">
              <label>Style</label>
              <select id="indicator-style">
                <option>Solid</option>
                <option>Dashed</option>
                <option>Dotted</option>
              </select>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="platform-button secondary" id="indicator-cancel">Cancel</button>
        <button class="platform-button" id="indicator-save">Save</button>
      </div>
    </div>
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>
  
  <style>
    /* Voice Assistant Styling */
    .voice-assistant {
      position: fixed;
      right: 20px;
      bottom: 20px;
      z-index: 900;
    }
    
    .voice-assistant-icon {
      width: 50px;
      height: 50px;
      background-color: var(--primary-color);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      color: white;
      transition: all 0.3s ease;
    }
    
    .voice-assistant-icon:hover {
      transform: scale(1.1);
    }
    
    .voice-assistant-panel {
      position: absolute;
      bottom: 60px;
      right: 0;
      width: 300px;
      background-color: var(--card-background);
      border-radius: 10px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.3);
      overflow: hidden;
      display: none;
      flex-direction: column;
    }
    
    .voice-assistant-panel.active {
      display: flex;
    }
    
    .voice-panel-header {
      padding: 15px;
      background-color: var(--panel-background);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .voice-panel-close {
      cursor: pointer;
      opacity: 0.6;
      transition: opacity 0.2s;
    }
    
    .voice-panel-close:hover {
      opacity: 1;
    }
    
    .voice-panel-body {
      padding: 15px;
      height: 300px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .assistant-message {
      background-color: var(--panel-background);
      padding: 10px 12px;
      border-radius: 10px;
      border-top-left-radius: 0;
      align-self: flex-start;
      max-width: 80%;
    }
    
    .user-message {
      background-color: var(--primary-color);
      padding: 10px 12px;
      border-radius: 10px;
      border-top-right-radius: 0;
      align-self: flex-end;
      max-width: 80%;
    }
    
    .voice-panel-footer {
      padding: 10px;
      border-top: 1px solid var(--border-color);
      display: flex;
      gap: 10px;
    }
    
    .voice-panel-footer input {
      flex: 1;
      padding: 8px 12px;
      background-color: rgba(40, 40, 80, 0.5);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-color);
    }
    
    .voice-panel-footer button {
      width: 36px;
      height: 36px;
      background-color: var(--primary-color);
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      cursor: pointer;
    }
    
    /* Custom Indicator Modal */
    .custom-indicator-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(15, 15, 26, 0.9);
      backdrop-filter: blur(8px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .custom-indicator-modal.visible {
      opacity: 1;
      visibility: visible;
    }
    
    .custom-indicator-container {
      background-color: var(--card-background);
      border-radius: 10px;
      width: 100%;
      max-width: 500px;
      box-shadow: 0 15px 30px rgba(0,0,0,0.3);
      transform: translateY(20px);
      transition: all 0.3s ease;
    }
    
    .custom-indicator-modal.visible .custom-indicator-container {
      transform: translateY(0);
    }
    
    .modal-header {
      padding: 15px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .modal-close {
      cursor: pointer;
      opacity: 0.6;
      transition: opacity 0.2s;
    }
    
    .modal-close:hover {
      opacity: 1;
    }
    
    .modal-body {
      padding: 15px;
    }
    
    .indicator-settings {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
    }
    
    .setting {
      flex: 1;
      min-width: 120px;
    }
    
    .setting label {
      display: block;
      font-size: 14px;
      margin-bottom: 5px;
      color: var(--text-secondary);
    }
    
    .setting input, .setting select {
      width: 100%;
      background-color: rgba(40, 40, 80, 0.5);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-color);
      padding: 8px;
    }
    
    .modal-footer {
      padding: 15px;
      border-top: 1px solid var(--border-color);
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    /* TradingView-style Context Menu */
    .chart-context-menu {
      position: fixed;
      background: #1e222d;
      border: 1px solid #2a2e39;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      padding: 4px 0;
      min-width: 220px;
      z-index: 10000;
      display: none;
      font-family: 'Outfit', sans-serif;
      font-size: 13px;
    }

    .chart-context-menu.active {
      display: block;
    }

    .context-menu-item {
      padding: 8px 16px;
      cursor: pointer;
      color: #d1d4dc;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: background 0.2s;
      user-select: none;
    }

    .context-menu-item:hover {
      background: #2a2e39;
    }

    .context-menu-item.active {
      color: #2962ff;
    }

    .context-menu-item .checkmark {
      width: 16px;
      margin-right: 8px;
      color: #2962ff;
    }

    .context-menu-item .shortcut {
      margin-left: auto;
      color: #787b86;
      font-size: 11px;
    }

    .context-menu-divider {
      height: 1px;
      background: #2a2e39;
      margin: 4px 0;
    }

    .context-menu-item.submenu::after {
      content: '';
      margin-left: auto;
      color: #787b86;
    }

    .context-menu-item.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .context-menu-item.disabled:hover {
      background: transparent;
    }

    .context-menu-section-title {
      padding: 6px 16px 4px;
      color: #787b86;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
  </style>

  <!-- Import Three.js and its extensions from CDN -->
  <!-- Use working CDN version -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <!-- TradingView Lightweight Charts -->
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
  
  <!-- Fragment shader for gravitational lensing effect -->
  <script id="gravitationalLensShader" type="x-shader/x-fragment">
    uniform sampler2D tDiffuse;
    uniform vec2 center;
    uniform float strength;
    uniform vec2 resolution;
    
    varying vec2 vUv;
    
    void main() {
      vec2 uv = vUv;
      vec2 centerCoord = center / resolution;
      vec2 delta = uv - centerCoord;
      float distance = length(delta);
      
      // Gravitational lensing - warps space more near the center
      float ratio = 1.0 + strength / (distance * 50.0 + 0.1);
      
      // Adjust UV based on gravitational pull
      vec2 directionToCenter = normalize(delta);
      vec2 newUv = centerCoord + delta * ratio;
      
      // Ensure we stay within bounds
      newUv = clamp(newUv, 0.0, 1.0);
      
      // Sample the texture with our modified UVs
      vec4 color = texture2D(tDiffuse, newUv);
      
      // Add slight color shift based on distance (like chromatic aberration)
      float blueShift = min(strength / (distance * 20.0), 0.2);
      color.b = mix(color.b, 1.0, blueShift);
      
      gl_FragColor = color;
    }
  </script>
  
  <!-- Vertex shader for particle system -->
  <script id="particleVertexShader" type="x-shader/x-vertex">
    uniform float time;
    uniform float size;
    uniform float speed;
    uniform vec3 flowDirection;
    
    attribute float age;
    attribute vec3 velocity;
    
    varying vec3 vColor;
    varying float vAlpha;
    
    void main() {
      // Basic particle aging
      float aliveTime = mod(time * speed + age, 1.0);
      
      // Color based on age and initial velocity
      vColor = mix(vec3(0.6, 0.5, 1.0), vec3(0.1, 0.2, 0.9), aliveTime);
      
      // Alpha that fades out at the end of life
      vAlpha = sin(aliveTime * 3.14159);
      
      // Calculate position with flowDirection influence
      vec3 newPosition = position + (velocity + flowDirection * 0.5) * aliveTime * 5.0;
      
      // Size that changes with life
      float particleSize = size * (1.0 - aliveTime * 0.5);
      
      // Final position
      vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
      gl_PointSize = particleSize * (300.0 / -mvPosition.z);
      gl_Position = projectionMatrix * mvPosition;
    }
  </script>
  
  <!-- Fragment shader for particles -->
  <script id="particleFragmentShader" type="x-shader/x-fragment">
    varying vec3 vColor;
    varying float vAlpha;
    
    void main() {
      // Calculate distance from center of point (for circular particles)
      vec2 xy = gl_PointCoord.xy - vec2(0.5);
      float radius = length(xy);
      
      // Soft circle shape with smooth edges
      float alpha = smoothstep(0.5, 0.4, radius) * vAlpha;
      
      // Final color with glow effect
      gl_FragColor = vec4(vColor, alpha);
    }
  </script>

  <script type="module">
    // Global error handler
    window.onerror = (msg, url, line, col, error) => {
      console.error('Global error:', { msg, url, line, col, error });
      const overlay = document.getElementById('loading-overlay');
      if (overlay) {
        overlay.innerHTML = `<div style="color: red; padding: 20px;"><h2>Error Loading Platform</h2><pre>${msg}\n${url}:${line}</pre></div>`;
      }
      return false;
    };

    // Import Moon AI Trading Platform v6.5
    let app;
    try {
      const module = await import('./src/main.js');
      app = module.app;
      console.log(' main.js loaded successfully');

      // Hide loading overlay after successful import
      setTimeout(() => {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
          overlay.classList.add('fade-out');
          setTimeout(() => { overlay.style.display = 'none'; }, 300);
        }
      }, 1000);
    } catch (e) {
      console.error(' Failed to load main.js:', e);
      const overlay = document.getElementById('loading-overlay');
      if (overlay) {
        overlay.innerHTML = `<div style="color: red; padding: 40px; text-align: center;">
          <h2>Error Loading Platform</h2>
          <pre style="text-align: left; max-width: 600px; margin: 20px auto; overflow: auto;">${e.message}\n\n${e.stack}</pre>
        </div>`;
      }
    }

    // Make app accessible globally
    window.moonAI = app;

    // Load Web Speech API if available
    let speechRecognition;
    let speechSynthesis;
    
    try {
      // Initialize speech recognition if available
      if ('webkitSpeechRecognition' in window) {
        speechRecognition = new webkitSpeechRecognition();
        speechRecognition.continuous = false;
        speechRecognition.interimResults = false;
        speechRecognition.lang = 'en-US';
      } else if ('SpeechRecognition' in window) {
        speechRecognition = new SpeechRecognition();
        speechRecognition.continuous = false;
        speechRecognition.interimResults = false;
        speechRecognition.lang = 'en-US';
      }
      
      // Initialize speech synthesis
      if ('speechSynthesis' in window) {
        speechSynthesis = window.speechSynthesis;
      }
    } catch (e) {
      console.error('Error initializing speech APIs:', e);
    }
  
    // Attempt to import supabase-integration.js
    let supabaseClient,
        signUp,
        signIn,
        signOut,
        onAuthStateChange,
        getMarketData,
        convertCandlestickData,
        subscribeToMarketData,
        getWatchlists,
        getSocialSentiment,
        getNews,
        getPrediction;
    
    // Progress tracking for loading indicators
    let loadingProgress = {
      initialized: false,
      connected: false,
      aiLoaded: false,
      chartPrepared: false,
      totalProgress: 0
    };

    // Toast notification system
    const toastContainer = document.getElementById('toast-container');
    
    function showToast(type, title, message, duration = 5000) {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      
      let iconSymbol = '';
      if (type === 'success') iconSymbol = '';
      else if (type === 'error') iconSymbol = '';
      else if (type === 'warning') iconSymbol = '';
      
      toast.innerHTML = `
        <div class="toast-icon">${iconSymbol}</div>
        <div class="toast-content">
          <div class="toast-title">${title}</div>
          <div class="toast-message">${message}</div>
        </div>
        <div class="toast-close"></div>
      `;
      
      toastContainer.appendChild(toast);
      
      // Add event listener to close button
      toast.querySelector('.toast-close').addEventListener('click', () => {
        removeToast(toast);
      });
      
      // Auto-remove after duration
      setTimeout(() => {
        removeToast(toast);
      }, duration);
      
      return toast;
    }
    
    function removeToast(toast) {
      if (toast.classList.contains('removing')) return;
      
      toast.classList.add('removing');
      toast.addEventListener('animationend', () => {
        toast.remove();
      });
    }

    // Update loading progress indicators
    function updateLoadingProgress(task, completed = false) {
      // Update task state
      if (task === 'initialize') loadingProgress.initialized = completed;
      else if (task === 'connect') loadingProgress.connected = completed;
      else if (task === 'ai') loadingProgress.aiLoaded = completed;
      else if (task === 'chart') loadingProgress.chartPrepared = completed;
      
      // Update visual indicators
      const taskElement = document.getElementById(`task-${task}`);
      if (taskElement) {
        if (completed) {
          taskElement.className = 'loading-task-complete';
          taskElement.innerHTML = '';
        }
      }
      
      // Calculate overall progress (each task = 25%)
      loadingProgress.totalProgress = 0;
      if (loadingProgress.initialized) loadingProgress.totalProgress += 25;
      if (loadingProgress.connected) loadingProgress.totalProgress += 25;
      if (loadingProgress.aiLoaded) loadingProgress.totalProgress += 25;
      if (loadingProgress.chartPrepared) loadingProgress.totalProgress += 25;
      
      // Update progress bar
      const progressBar = document.getElementById('loading-progress-bar');
      if (progressBar) {
        progressBar.style.width = `${loadingProgress.totalProgress}%`;
      }
      
      // Check if all tasks are complete
      if (loadingProgress.totalProgress >= 100) {
        // Fade out the loading overlay after a short delay
        setTimeout(() => {
          const overlay = document.getElementById('loading-overlay');
          if (overlay) {
            overlay.classList.add('fade-out');
            // Optional: completely remove from DOM after fade animation
            setTimeout(() => {
              overlay.style.display = 'none';
            }, 300);
          }
        }, 500);
      }
    }
    
    try {
      // Disable Supabase - using local CSV data instead
      console.log('Skipping Supabase initialization - using local data');

      // Create stub functions for Supabase
      supabaseClient = null;
      signUp = async () => ({ error: 'Supabase disabled' });
      signIn = async () => ({ error: 'Supabase disabled' });
      signOut = async () => ({ error: 'Supabase disabled' });
      onAuthStateChange = () => ({ data: { subscription: { unsubscribe: () => {} } } });
      getMarketData = async () => ({ error: 'Using local CSV data' });
      convertCandlestickData = (data) => data;
      subscribeToMarketData = () => ({ unsubscribe: () => {} });
      getWatchlists = async () => ({ data: [], error: null });
      getSocialSentiment = async () => ({ data: null, error: 'Disabled' });
      getNews = async () => ({ data: [], error: null });
      getPrediction = async () => ({ data: null, error: 'Disabled' });

      // Mark initialization task as complete
      updateLoadingProgress('initialize', true);
      
    } catch (error) {
      console.error('Error importing Supabase integration:', error);
      showToast('error', 'Connection Error', 'Could not load Supabase integration. Using mock data instead.');
      
      // Minimal fallback stubs
      signUp = async () => ({ error: { message: 'Signup not available' } });
      signIn = async () => ({ error: { message: 'SignIn not available' } });
      signOut = async () => ({ data: null, error: 'SignOut not available' });
      onAuthStateChange = () => () => {};
      getMarketData = async () => [];
      convertCandlestickData = (d) => d;
      subscribeToMarketData = () => () => {};
      getWatchlists = async () => [];
      getSocialSentiment = async () => ({ data: null, error: 'Not available' });
      getNews = async () => ({ data: [], error: 'Not available' });
      getPrediction = async () => ({ data: null, error: 'Not available' });
      
      // Still mark initialization as complete, even with mock data
      updateLoadingProgress('initialize', true);
    }

    // Global variables
    let chart;
    let currentSymbol = 'ATANA';
    let currentTimeframe = '1w';
    let chartReady = false;

    // DOM elements
    const loadingOverlay = document.getElementById('loading-overlay');
    const chartLoading = document.getElementById('chart-loading');
    const authModal = document.getElementById('auth-modal');
    const loginButton = document.getElementById('login-button');
    const userProfile = document.getElementById('user-profile');
    const leftSidebar = document.getElementById('left-sidebar');
    const rightPanels = document.getElementById('right-panels');
    const sidebarToggle = document.getElementById('sidebar-toggle');
    const panelsToggle = document.getElementById('panels-toggle');

    // Sidebar toggle
    sidebarToggle.addEventListener('click', () => {
      leftSidebar.classList.toggle('collapsed');
      sidebarToggle.classList.toggle('collapsed');
      if (sidebarToggle.classList.contains('collapsed')) {
        sidebarToggle.innerHTML = '<span></span>';
      } else {
        sidebarToggle.innerHTML = '<span></span>';
      }
    });

    // Panels toggle (TradingView-style widgetbar hider)
    panelsToggle.addEventListener('click', () => {
      const isCollapsed = rightPanels.classList.toggle('collapsed');
      panelsToggle.classList.toggle('collapsed');
      document.querySelector('.platform-container')?.classList.toggle('right-panel-collapsed', isCollapsed);

      // Update accessibility and tooltip
      panelsToggle.setAttribute('aria-expanded', !isCollapsed);
      const tooltip = panelsToggle.querySelector('.tv-tooltip');
      if (tooltip) {
        tooltip.textContent = isCollapsed ? 'Show panel' : 'Hide panel';
      }

      // Dispatch custom event for chart resize
      window.dispatchEvent(new CustomEvent('panelToggle', {
        detail: { panel: 'right', collapsed: isCollapsed }
      }));
    });

    // Tabs and forms
    const loginTab = document.querySelector('[data-tab="login"]');
    const signupTab = document.querySelector('[data-tab="signup"]');
    const loginForm = document.getElementById('login-form');
    const signupForm = document.getElementById('signup-form');

    // Additional controls
    const timeWarpBtn = document.getElementById('time-warp-btn');
    const vrModeBtn = document.getElementById('vr-mode-btn');
    const lensBtn = document.getElementById('lens-btn');
    const indicatorBtn = document.getElementById('indicator-btn');
    const comparisonBtn = document.getElementById('comparison-btn');

    // Timeframe buttons
    const timeframeButtons = document.querySelectorAll('.timeframe-button');
    timeframeButtons.forEach(button => {
      button.addEventListener('click', () => {
        timeframeButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        currentTimeframe = button.getAttribute('data-timeframe');
        loadChartData();
      });
    });

    // Panels
    const aiContent = document.getElementById('ai-content');
    const sentimentContent = document.getElementById('sentiment-content');
    const newsContent = document.getElementById('news-content');
    
    // Panel refresh buttons
    document.getElementById('ai-refresh').addEventListener('click', () => {
      loadAIPredictions();
    });
    document.getElementById('sentiment-refresh').addEventListener('click', () => {
      loadSocialSentiment();
    });
    document.getElementById('news-refresh').addEventListener('click', () => {
      loadMarketNews();
    });

    // Tooltip functionality
    document.addEventListener('mouseover', function(e) {
      const tooltipAttr = e.target.getAttribute('data-tooltip');
      if (tooltipAttr) {
        showTooltip(e.target, tooltipAttr);
      }
    });

    document.addEventListener('mouseout', function(e) {
      if (e.target.getAttribute('data-tooltip')) {
        hideTooltip();
      }
    });

    function showTooltip(element, text) {
      let tooltip = document.querySelector('.tooltip');
      if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.className = 'tooltip';
        document.body.appendChild(tooltip);
      }
      
      tooltip.textContent = text;
      tooltip.classList.add('visible');
      
      const rect = element.getBoundingClientRect();
      const tooltipRect = tooltip.getBoundingClientRect();
      
      // Position the tooltip
      tooltip.style.left = `${rect.left + (rect.width / 2) - (tooltipRect.width / 2)}px`;
      tooltip.style.top = `${rect.top - tooltipRect.height - 10}px`;
    }

    function hideTooltip() {
      const tooltip = document.querySelector('.tooltip');
      if (tooltip) {
        tooltip.classList.remove('visible');
      }
    }

    // Chart class with advanced features
    class CandlestickChart {
      constructor(container) {
        this.container = container;
        this.data = [];
        this.isReady = false;
        this.clock = new THREE.Clock();
        this.darkPoolMasses = [];  // Track dark pool masses
        this.particleSystems = []; // All particle systems
        this.heatmapLayer = null;  // Heatmap for liquidity visualization
        this.tooltips = [];        // Array of tooltip objects for visualization
        
        // We'll initialize the scene once Three.js is loaded
        this.initializeWhenReady();
      }

      async initializeWhenReady() {
        // Check if Three.js is loaded, if not, wait for it
        if (typeof THREE === 'undefined' ||
            typeof THREE.OrbitControls === 'undefined') {
          setTimeout(() => this.initializeWhenReady(), 100);
          return;
        }

        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x0f0f1a);

        // Camera
        this.camera = new THREE.PerspectiveCamera(
          75,
          this.container.clientWidth / this.container.clientHeight,
          0.1,
          1000
        );
        this.camera.position.set(5, 15, 30);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ 
          antialias: true,
          alpha: true,
          logarithmicDepthBuffer: true // Better for mixed scale scenes
        });
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        this.container.appendChild(this.renderer.domElement);

        // Postprocessing setup
        this.setupPostprocessing();

        // Controls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        // TradingView-style controls
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.1; // Smoother damping
        this.controls.maxPolarAngle = Math.PI / 1.8; // Allow more rotation
        this.controls.minDistance = 2;   // Very close zoom
        this.controls.maxDistance = 200; // Very far zoom
        this.controls.panSpeed = 2.0;    // Responsive panning
        this.controls.enablePan = true;  // Enable panning
        this.controls.screenSpacePanning = true;
        this.controls.zoomSpeed = 1.2;   // Smooth zoom
        this.controls.mouseButtons = {
          LEFT: THREE.MOUSE.PAN,      // Left-click to pan (TradingView style)
          MIDDLE: THREE.MOUSE.DOLLY,  // Middle mouse to zoom
          RIGHT: THREE.MOUSE.ROTATE   // Right-click to rotate
        };

        // Groups
        this.candlesticks = new THREE.Group();
        this.volumeBars = new THREE.Group();
        this.darkPoolGroup = new THREE.Group(); // For dark pool visualizations
        this.particleGroup = new THREE.Group(); // For particle systems
        this.tooltipGroup = new THREE.Group(); // For 3D tooltips
        
        this.scene.add(this.candlesticks);
        this.scene.add(this.volumeBars);
        this.scene.add(this.darkPoolGroup);
        this.scene.add(this.particleGroup);
        this.scene.add(this.tooltipGroup);

        // Grid
        const gridHelper = new THREE.GridHelper(100, 20, 0x222236, 0x1a1a2e);
        this.scene.add(gridHelper);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        this.scene.add(directionalLight);
        
        // Add point lights for better highlights
        const pointLight1 = new THREE.PointLight(0x6c5ce7, 0.5, 100);
        pointLight1.position.set(20, 30, 20);
        this.scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0x00cec9, 0.3, 50);
        pointLight2.position.set(-10, 20, -10);
        this.scene.add(pointLight2);

        // Initialize particle system materials
        this.initializeParticleMaterials();
        
        // Initialize heatmap
        this.initializeHeatmap();

        // Event listeners
        window.addEventListener('resize', this.onWindowResize.bind(this));
        this.renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
        
        // For gravitational lens and bloom effects
        this.lensActive = false;
        this.gravityStrength = 1.0;
        this.darkPoolsVisible = true;
        
        // Create raycaster for tooltips
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();

        // Add TradingView-style keyboard controls
        this.setupKeyboardControls();

        // Mark the chart as ready
        this.isReady = true;

        // Signal that the chart is prepared
        updateLoadingProgress('chart', true);

        // Start animation
        this.animate();
      }

      // TradingView-style keyboard shortcuts
      setupKeyboardControls() {
        document.addEventListener('keydown', (e) => {
          // Don't interfere with text inputs
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          const barMove = 0.6;    // Move 1 bar at a time
          const fastMove = 5;     // Fast pan
          const zoomFactor = 0.9; // Zoom multiplier

          switch(e.key) {
            //  /  : Move 1 bar left/right (TradingView default)
            case 'ArrowLeft':
              if (e.ctrlKey || e.metaKey) {
                // Ctrl/Cmd +  : Move many bars left
                this.controls.target.x -= fastMove;
                this.camera.position.x -= fastMove;
              } else {
                //  : Move 1 bar left
                this.controls.target.x -= barMove;
                this.camera.position.x -= barMove;
              }
              e.preventDefault();
              break;

            case 'ArrowRight':
              if (e.ctrlKey || e.metaKey) {
                // Ctrl/Cmd +  : Move many bars right
                this.controls.target.x += fastMove;
                this.camera.position.x += fastMove;
              } else {
                //  : Move 1 bar right
                this.controls.target.x += barMove;
                this.camera.position.x += barMove;
              }
              e.preventDefault();
              break;

            // Ctrl/Alt + / : Zoom in/out (TradingView style)
            case 'ArrowUp':
              if (e.ctrlKey || e.metaKey || e.altKey) {
                // Zoom in (move camera closer)
                const distance = this.camera.position.distanceTo(this.controls.target);
                const newDistance = Math.max(distance * zoomFactor, this.controls.minDistance);
                const direction = new THREE.Vector3();
                direction.subVectors(this.camera.position, this.controls.target).normalize();
                this.camera.position.copy(this.controls.target).add(direction.multiplyScalar(newDistance));
                e.preventDefault();
              }
              break;

            case 'ArrowDown':
              if (e.ctrlKey || e.metaKey || e.altKey) {
                // Zoom out (move camera away)
                const distance = this.camera.position.distanceTo(this.controls.target);
                const newDistance = Math.min(distance / zoomFactor, this.controls.maxDistance);
                const direction = new THREE.Vector3();
                direction.subVectors(this.camera.position, this.controls.target).normalize();
                this.camera.position.copy(this.controls.target).add(direction.multiplyScalar(newDistance));
                e.preventDefault();
              }
              break;

            // + / - : Zoom in/out
            case '+':
            case '=':
              const distPlus = this.camera.position.distanceTo(this.controls.target);
              const newDistPlus = Math.max(distPlus * zoomFactor, this.controls.minDistance);
              const dirPlus = new THREE.Vector3();
              dirPlus.subVectors(this.camera.position, this.controls.target).normalize();
              this.camera.position.copy(this.controls.target).add(dirPlus.multiplyScalar(newDistPlus));
              e.preventDefault();
              break;

            case '-':
            case '_':
              const distMinus = this.camera.position.distanceTo(this.controls.target);
              const newDistMinus = Math.min(distMinus / zoomFactor, this.controls.maxDistance);
              const dirMinus = new THREE.Vector3();
              dirMinus.subVectors(this.camera.position, this.controls.target).normalize();
              this.camera.position.copy(this.controls.target).add(dirMinus.multiplyScalar(newDistMinus));
              e.preventDefault();
              break;

            // Home: Auto-fit (show all candles)
            case 'Home':
              this.resetView();
              e.preventDefault();
              break;

            // End: Jump to latest candles (like TradingView's >> button)
            case 'End':
              this.jumpToLatest();
              e.preventDefault();
              break;
          }

          this.controls.update();
        });
      }

      // Reset camera to show all candles
      resetView() {
        if (!this.data || this.data.length === 0) return;

        const dataLength = this.data.length;
        this.controls.target.set(0, 0, 0);
        this.camera.position.set(dataLength * 0.3, 15, 40);
        this.controls.update();
      }

      // Jump to latest candles
      jumpToLatest() {
        if (!this.data || this.data.length === 0) return;

        const dataLength = this.data.length;
        this.controls.target.x = dataLength * 0.6;
        this.camera.position.x = dataLength * 0.6;
        this.controls.update();
      }
      
      // Initialize post-processing effects (bloom + lens)
      setupPostprocessing() {
        // Simplified - skip post-processing for now (missing dependencies)
        this.composer = null;
        return;

        /* Disabled due to missing CDN libraries
        // Create composer
        this.composer = new THREE.EffectComposer(this.renderer);

        // Add render pass
        const renderPass = new THREE.RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);
        
        // Add bloom for glow effects
        this.bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(this.container.clientWidth, this.container.clientHeight),
          0.3,  // strength
          0.4,  // radius
          0.9   // threshold
        );
        this.composer.addPass(this.bloomPass);
        
        // Create custom gravitational lens shader
        this.lensPass = new THREE.ShaderPass({
          uniforms: {
            tDiffuse: { value: null },
            center: { value: new THREE.Vector2(0.5, 0.5) },
            strength: { value: 0.0 },
            resolution: { value: new THREE.Vector2(
              this.container.clientWidth, 
              this.container.clientHeight
            )}
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: document.getElementById('gravitationalLensShader').textContent
        });
        
        this.composer.addPass(this.lensPass);

        // Make sure the final pass outputs to screen
        this.lensPass.renderToScreen = true;
        */
      }
      
      // Initialize particle materials using custom shaders
      initializeParticleMaterials() {
        // Get shader code from script tags
        const particleVertexShader = document.getElementById('particleVertexShader').textContent;
        const particleFragmentShader = document.getElementById('particleFragmentShader').textContent;
        
        // Create shader material for particles
        this.particleMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            size: { value: 3.0 },
            speed: { value: 0.5 },
            flowDirection: { value: new THREE.Vector3(0, 0.2, 0) }
          },
          vertexShader: particleVertexShader,
          fragmentShader: particleFragmentShader,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          transparent: true
        });
      }
      
      // Initialize heatmap layer for volume/liquidity visualization
      initializeHeatmap() {
        // Create a plane geometry for the heatmap
        const geometry = new THREE.PlaneGeometry(100, 50, 100, 50);
        
        // Create a custom heatmap material
        const heatmapMaterial = new THREE.ShaderMaterial({
          uniforms: {
            volumeData: { value: null }, // Will be updated with volume data texture
            minPrice: { value: 0.0 },
            maxPrice: { value: 100.0 },
            hotColor: { value: new THREE.Color(0xff7675) },  // Red for high volume
            coldColor: { value: new THREE.Color(0x00cec9) }  // Blue for low volume
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D volumeData;
            uniform float minPrice;
            uniform float maxPrice;
            uniform vec3 hotColor;
            uniform vec3 coldColor;
            
            varying vec2 vUv;
            
            void main() {
              float volume = texture2D(volumeData, vUv).r;
              vec3 color = mix(coldColor, hotColor, volume);
              float alpha = smoothstep(0.0, 0.5, volume) * 0.6;
              gl_FragColor = vec4(color, alpha);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          side: THREE.DoubleSide
        });
        
        // Create the heatmap mesh and position it
        this.heatmapLayer = new THREE.Mesh(geometry, heatmapMaterial);
        this.heatmapLayer.rotation.x = -Math.PI / 2; // Make it horizontal
        this.heatmapLayer.position.y = -0.1; // Just below the grid
        this.heatmapLayer.visible = false; // Hidden by default
        
        this.scene.add(this.heatmapLayer);
      }

      onWindowResize() {
        this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
      }

      animate() {
        requestAnimationFrame(this.animate.bind(this));
        this.controls.update();

        // If lens is active, apply a placeholder lens effect
        if (this.lensActive) {
          this.applyGravitationalLensEffect();
        }

        this.renderer.render(this.scene, this.camera);
      }

      setData(data) {
        if (!this.isReady) {
          // If chart isn't ready yet, queue the data to be set when ready
          setTimeout(() => this.setData(data), 100);
          return;
        }
        
        this.data = data;
        this.minPrice = Math.min(...data.map(d => d.low));
        this.maxPrice = Math.max(...data.map(d => d.high));
        this.maxVolume = Math.max(...data.map(d => d.volume));
        this.renderCandlesticks();
        
        // Hide chart loading overlay
        if (chartLoading) {
          chartLoading.classList.add('loaded');
        }
      }

      renderCandlesticks() {
        // Clear existing
        while (this.candlesticks.children.length > 0) {
          this.candlesticks.remove(this.candlesticks.children[0]);
        }
        while (this.volumeBars.children.length > 0) {
          this.volumeBars.remove(this.volumeBars.children[0]);
        }
        
        // Also clear market depth if exists
        if (this.marketDepth) {
          this.scene.remove(this.marketDepth);
          this.marketDepth = null;
        }

        const priceRange = this.maxPrice - this.minPrice;
        const scaleFactor = 20 / priceRange;

        const bullishMaterial = new THREE.MeshStandardMaterial({
          color: 0x00b894,
          metalness: 0.2,
          roughness: 0.5
        });
        const bearishMaterial = new THREE.MeshStandardMaterial({
          color: 0xff7675,
          metalness: 0.2,
          roughness: 0.5
        });
        const wickMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });

        // Arrays to hold price distribution data for market depth
        const pricePoints = 100; // Resolution of depth chart
        const bidDistribution = new Array(pricePoints).fill(0);
        const askDistribution = new Array(pricePoints).fill(0);
        
        this.data.forEach((candle, index) => {
          const isBullish = candle.close >= candle.open;
          const material = isBullish ? bullishMaterial : bearishMaterial;

          const bodyHeight = Math.abs(candle.open - candle.close) * scaleFactor;
          const bodyBottom = Math.min(candle.open, candle.close);
          const bodyPosition = (bodyBottom - this.minPrice) * scaleFactor + bodyHeight / 2;

          // Candle body
          const bodyGeometry = new THREE.BoxGeometry(0.8, Math.max(bodyHeight, 0.01), 0.8);
          const body = new THREE.Mesh(bodyGeometry, material);
          body.position.set(index * 1.2, bodyPosition, 0);

          // Wick
          const wickGeometry = new THREE.BufferGeometry();
          const wickStart = new THREE.Vector3(index * 1.2, (candle.low - this.minPrice) * scaleFactor, 0);
          const wickEnd = new THREE.Vector3(index * 1.2, (candle.high - this.minPrice) * scaleFactor, 0);
          wickGeometry.setFromPoints([wickStart, wickEnd]);
          const wick = new THREE.Line(wickGeometry, wickMaterial);

          // Volume bar
          const volumeHeight = (candle.volume / this.maxVolume) * 10;
          const volumeGeometry = new THREE.BoxGeometry(0.7, volumeHeight, 0.7);
          const volumeMat = new THREE.MeshStandardMaterial({
            color: isBullish ? 0x00b894 : 0xff7675,
            transparent: true,
            opacity: 0.5
          });
          const volumeBar = new THREE.Mesh(volumeGeometry, volumeMat);
          volumeBar.position.set(index * 1.2, volumeHeight / 2, -3);

          this.candlesticks.add(body);
          this.candlesticks.add(wick);
          this.volumeBars.add(volumeBar);
          
          // Contribute to market depth data
          // For demonstration, we'll use candle ranges to simulate bid/ask distribution
          // In a real implementation, you would use actual order book data
          
          // Convert price to distribution index
          const priceRange = this.maxPrice - this.minPrice;
          const indexLow = Math.floor((candle.low - this.minPrice) / priceRange * pricePoints);
          const indexHigh = Math.floor((candle.high - this.minPrice) / priceRange * pricePoints);
          const indexClose = Math.floor((candle.close - this.minPrice) / priceRange * pricePoints);
          
          // Add volume to distribution (splitting between bid/ask based on bullish/bearish)
          const volumeContribution = candle.volume / this.maxVolume * 5;
          
          for (let i = indexLow; i <= indexHigh; i++) {
            if (i >= 0 && i < pricePoints) {
              // More volume near close price, less at extremes
              const distanceFromClose = Math.abs(i - indexClose) / (indexHigh - indexLow || 1);
              const contribution = volumeContribution * (1 - distanceFromClose);
              
              if (isBullish) {
                // For bullish candles, more bids at bottom, more asks near top
                const bidWeight = 1 - (i - indexLow) / (indexHigh - indexLow || 1);
                bidDistribution[i] += contribution * bidWeight;
                askDistribution[i] += contribution * (1 - bidWeight);
              } else {
                // For bearish candles, more asks at top, more bids near bottom
                const askWeight = (i - indexLow) / (indexHigh - indexLow || 1);
                bidDistribution[i] += contribution * (1 - askWeight);
                askDistribution[i] += contribution * askWeight;
              }
            }
          }
        });
        
        // Create market depth visualization
        this.createMarketDepthVisualization(bidDistribution, askDistribution, scaleFactor);

        this.candlesticks.position.x = -this.data.length * 0.6;
        this.volumeBars.position.x = -this.data.length * 0.6;
      }
      
      createMarketDepthVisualization(bidDistribution, askDistribution, scaleFactor) {
        // Create a market depth surface
        const width = 100; // Width of the surface
        const depth = 30;  // Depth (z-dimension) of the surface
        
        // Create geometry for the market depth
        const resolution = bidDistribution.length;
        const geometry = new THREE.BufferGeometry();
        
        const vertices = [];
        const colors = [];
        const indices = [];
        
        // Create a curved surface with vertices
        for (let z = 0; z < depth; z++) {
          for (let x = 0; x < resolution; x++) {
            // Position
            const xPos = (x / resolution) * width - width / 2;
            // y position based on distribution data, more height closer to center
            const zDepthFactor = 1 - (z / depth);
            const bidHeight = bidDistribution[x] * zDepthFactor * 3;
            const askHeight = askDistribution[x] * zDepthFactor * 3;
            const yPos = (x < resolution / 2) ? bidHeight : askHeight;
            const zPos = -5 - z;
            
            vertices.push(xPos, yPos, zPos);
            
            // Colors
            const colorIntensity = Math.min(1.0, yPos * 0.5);
            if (x < resolution / 2) {
                // Bids - green gradient
                colors.push(0, 0.5 + colorIntensity * 0.5, 0.2 + colorIntensity * 0.8);
            } else {
                // Asks - red gradient
                colors.push(0.5 + colorIntensity * 0.5, 0.1 + colorIntensity * 0.2, 0.1 + colorIntensity * 0.3);
            }
        }
      }
        
        // Create faces (triangles) between vertices
        for (let z = 0; z < depth - 1; z++) {
            for (let x = 0; x < resolution - 1; x++) {
                const topLeft = z * resolution + x;
                const topRight = topLeft + 1;
                const bottomLeft = (z + 1) * resolution + x;
                const bottomRight = bottomLeft + 1;
                
                // First triangle
                indices.push(topLeft, bottomLeft, topRight);
                // Second triangle
                indices.push(topRight, bottomLeft, bottomRight);
            }
        }
        
        // Set attributes
        geometry.setIndex(indices);
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        // Create material
        const material = new THREE.MeshStandardMaterial({
            vertexColors: true,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.85,
            metalness: 0.2,
            roughness: 0.8
        });
        
        // Create mesh
        this.marketDepth = new THREE.Mesh(geometry, material);
        this.marketDepth.position.x = -this.data.length * 0.5;
        this.marketDepth.position.y = 0;
        this.scene.add(this.marketDepth);
        
        // Add subtle animation
        const animate = () => {
            if (this.marketDepth) {
                const time = Date.now() * 0.001;
                // Subtle movement based on time
                for (let i = 0; i < geometry.attributes.position.array.length / 3; i++) {
                    const idx = i * 3;
                    const x = geometry.attributes.position.array[idx];
                    const z = geometry.attributes.position.array[idx + 2];
                    // Add small wave effect
                    geometry.attributes.position.array[idx + 1] += Math.sin(time + x * 0.1 + z * 0.1) * 0.01;
                }
                geometry.attributes.position.needsUpdate = true;
            }
        };
        
        // Run animation every few frames to save performance
        this.marketDepthAnimationInterval = setInterval(animate, 100);
      }

      toggleView() {
        // Cycle camera position
        if (this.camera.position.z > 20) {
          this.camera.position.set(0, 35, 0);
          this.controls.target.set(0, 0, 0);
        } else if (this.camera.position.y > 20) {
          this.camera.position.set(30, 10, 0);
          this.controls.target.set(0, 10, 0);
        } else {
          this.camera.position.set(5, 15, 30);
          this.controls.target.set(0, 10, 0);
        }
      }

      onMouseMove(event) {
        // Calculate mouse position in normalized device coordinates (-1 to +1)
        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        // Check for dark pool tooltips
        this.checkDarkPoolTooltips();
      }
      
      // Check if mouse is over any dark pool mass and show tooltip
      checkDarkPoolTooltips() {
        if (!this.isReady || !this.darkPoolsVisible) return;
        
        // Update the raycaster with the camera and mouse position
        this.raycaster.setFromCamera(this.mouse, this.camera);
        
        // Check for intersections with dark pool objects
        const intersects = this.raycaster.intersectObjects(this.darkPoolGroup.children);
        
        // If we have intersections, show tooltip information
        if (intersects.length > 0) {
          const darkPool = intersects[0].object;
          const poolData = darkPool.userData.darkPoolData;
          
          // Create tooltip text for this dark pool
          let tooltipHtml = `
            <div class="dark-pool-tooltip">
              <div class="tooltip-title">Dark Pool Activity</div>
              <div class="tooltip-row">
                <span class="tooltip-label">Volume:</span>
                <span class="tooltip-value">${poolData.volume.toLocaleString()}</span>
              </div>
              <div class="tooltip-row">
                <span class="tooltip-label">Price:</span>
                <span class="tooltip-value">$${poolData.price.toFixed(2)}</span>
              </div>
              <div class="tooltip-row">
                <span class="tooltip-label">Gravitational Pull:</span>
                <span class="tooltip-value">${(poolData.gravity * 100).toFixed(1)}%</span>
              </div>
            </div>
          `;
          
          // Display tooltip
          showTooltip(intersects[0].object.position, tooltipHtml);
        } else {
          // Hide tooltip when not hovering
          hideTooltip();
        }
        
        // Helper function to show tooltips
        function showTooltip(position, html) {
          // Get tooltip or create one if it doesn't exist
          let tooltip = document.querySelector('.tooltip-3d');
          if (!tooltip) {
            tooltip = document.createElement('div');
            tooltip.className = 'tooltip-3d';
            document.body.appendChild(tooltip);
            
            // Style the tooltip
            tooltip.style.position = 'absolute';
            tooltip.style.padding = '10px 15px';
            tooltip.style.backgroundColor = 'rgba(26, 26, 46, 0.95)';
            tooltip.style.borderRadius = '4px';
            tooltip.style.color = '#fff';
            tooltip.style.fontSize = '14px';
            tooltip.style.pointerEvents = 'none';
            tooltip.style.zIndex = '1000';
            tooltip.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.3)';
            tooltip.style.borderLeft = '3px solid var(--primary-color)';
            tooltip.style.maxWidth = '300px';
          }
          
          // Add the tooltip content
          tooltip.innerHTML = html;
          
          // Position tooltip - convert 3D position to 2D screen coordinates
          const vector = position.clone();
          vector.project(this.camera);
          
          const x = (vector.x * 0.5 + 0.5) * this.renderer.domElement.clientWidth;
          const y = (vector.y * -0.5 + 0.5) * this.renderer.domElement.clientHeight;
          
          tooltip.style.left = `${x}px`;
          tooltip.style.top = `${y - tooltip.offsetHeight - 15}px`; // Position above the point
          tooltip.style.display = 'block';
        }
        
        // Helper function to hide tooltips
        function hideTooltip() {
          const tooltip = document.querySelector('.tooltip-3d');
          if (tooltip) {
            tooltip.style.display = 'none';
          }
        }
      }
  
      // Create dark pool visualization
      createDarkPool(position, volume, price) {
        // Create the dark pool object
        const geometry = new THREE.SphereGeometry(1, 32, 32);
        
        // Create a custom shader material for the dark pool
        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            color: { value: new THREE.Color(0x6c5ce7) },
            strength: { value: volume / this.maxVolume }
          },
          vertexShader: `
            varying vec3 vPosition;
            varying vec3 vNormal;
            
            void main() {
              vPosition = position;
              vNormal = normal;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            uniform vec3 color;
            uniform float strength;
            
            varying vec3 vPosition;
            varying vec3 vNormal;
            
            void main() {
              // Pulsating effect
              float pulse = 0.5 + 0.5 * sin(time * 2.0);
              
              // Fresnel effect (more glow at edges)
              vec3 viewDirection = normalize(cameraPosition - vPosition);
              float fresnel = dot(viewDirection, vNormal);
              fresnel = pow(1.0 - fresnel, 3.0);
              
              // Combine effects
              vec3 finalColor = mix(color, color * 1.5, pulse * fresnel);
              float alpha = 0.7 * strength + 0.2 * fresnel * pulse;
              
              gl_FragColor = vec4(finalColor, alpha);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        
        // Create the sphere
        const darkPoolSphere = new THREE.Mesh(geometry, material);
        
        // Size based on volume
        const size = Math.max(1, Math.min(5, 1 + 4 * (volume / this.maxVolume)));
        darkPoolSphere.scale.set(size, size, size);
        
        // Position
        darkPoolSphere.position.copy(position);
        
        // Store dark pool data
        darkPoolSphere.userData.darkPoolData = {
          volume: volume,
          price: price,
          gravity: volume / this.maxVolume,
          position: position.clone()
        };
        
        // Add to dark pool group
        this.darkPoolGroup.add(darkPoolSphere);
        this.darkPoolMasses.push(darkPoolSphere);
        
        // Create particle effects for this dark pool
        this.createParticleEffect(position, volume);
        
        return darkPoolSphere;
      }
      
      // Create particle system for flow visualization
      createParticleEffect(position, volume) {
        const PARTICLE_COUNT = Math.min(2000, Math.floor(volume / 10));
        
        // Create geometry for particles
        const geometry = new THREE.BufferGeometry();
        
        // Create arrays for attributes
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const velocities = new Float32Array(PARTICLE_COUNT * 3);
        const ages = new Float32Array(PARTICLE_COUNT);
        
        // Fill the arrays with random values
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          // Position - start near dark pool
          const radius = Math.random() * 2;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          
          positions[i * 3] = position.x + radius * Math.sin(phi) * Math.cos(theta);
          positions[i * 3 + 1] = position.y + radius * Math.sin(phi) * Math.sin(theta);
          positions[i * 3 + 2] = position.z + radius * Math.cos(phi);
          
          // Velocity - move outward from center
          velocities[i * 3] = Math.sin(phi) * Math.cos(theta) * (0.2 + Math.random() * 0.8);
          velocities[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * (0.2 + Math.random() * 0.8);
          velocities[i * 3 + 2] = Math.cos(phi) * (0.2 + Math.random() * 0.8);
          
          // Random starting age
          ages[i] = Math.random();
        }
        
        // Add attributes to geometry
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
        geometry.setAttribute('age', new THREE.BufferAttribute(ages, 1));
        
        // Create material - clone from the base particle material
        const material = this.particleMaterial.clone();
        
        // Customize material for this particle system
        material.uniforms.size.value = Math.max(2, 3 * (volume / this.maxVolume));
        material.uniforms.flowDirection.value.set(
          Math.random() * 0.4 - 0.2,
          Math.random() * 0.4,
          Math.random() * 0.4 - 0.2
        );
        
        // Create the particle system
        const particleSystem = new THREE.Points(geometry, material);
        
        // Add to scene
        this.particleGroup.add(particleSystem);
        this.particleSystems.push({
          system: particleSystem,
          material: material,
          darkPoolPosition: position.clone(),
          volume: volume
        });
        
        return particleSystem;
      }
      
      // Create heatmap data texture
      updateHeatmapData() {
        if (!this.heatmapLayer || !this.data || this.data.length === 0) return;
        
        // Create data array for volume distribution
        const width = 256;
        const height = 256;
        const size = width * height;
        const data = new Uint8Array(size * 4); // RGBA
        
        // Initialize with zeros
        for (let i = 0; i < size * 4; i++) {
          data[i] = 0;
        }
        
        // Map price range to texture coordinates
        const priceRange = this.maxPrice - this.minPrice;
        
        // Fill data based on volume at each price point
        for (let i = 0; i < this.data.length; i++) {
          const candle = this.data[i];
          
          // Map time to X coordinate (0 to width-1)
          const x = Math.floor((i / this.data.length) * (width - 1));
          
          // Calculate range of prices in this candle
          const highY = Math.floor(((candle.high - this.minPrice) / priceRange) * (height - 1));
          const lowY = Math.floor(((candle.low - this.minPrice) / priceRange) * (height - 1));
          
          // Volume normalized to 0-1 range
          const volumeValue = Math.min(1, candle.volume / this.maxVolume);
          
          // Fill in the range from low to high with volume data
          for (let y = lowY; y <= highY; y++) {
            // Distance from price center (for gaussian distribution)
            const priceCenter = (candle.open + candle.close) / 2;
            const priceCenterY = Math.floor(((priceCenter - this.minPrice) / priceRange) * (height - 1));
            const distance = Math.abs(y - priceCenterY) / (highY - lowY || 1);
            
            // Gaussian dropoff
            const intensity = volumeValue * Math.exp(-5 * distance * distance);
            
            // Calculate index in the data array
            const index = (y * width + x) * 4;
            
            // Add to existing value (allows for accumulation)
            data[index] = Math.min(255, data[index] + Math.floor(intensity * 255));
            data[index + 1] = 0;
            data[index + 2] = 0;
            data[index + 3] = 255;
          }
        }
        
        // Create texture from data
        const texture = new THREE.DataTexture(data, width, height, THREE.RGBAFormat);
        texture.needsUpdate = true;
        
        // Update heatmap material
        this.heatmapLayer.material.uniforms.volumeData.value = texture;
        this.heatmapLayer.material.uniforms.minPrice.value = this.minPrice;
        this.heatmapLayer.material.uniforms.maxPrice.value = this.maxPrice;
        
        // Show heatmap
        this.heatmapLayer.visible = true;
      }
      
      // Update advanced gravitational lens effect
      applyGravitationalLensEffect() {
        if (!this.isReady || !this.lensActive) return;
        
        // Get the elapsed time
        const time = this.clock.getElapsedTime();
        
        // Update particle systems
        for (const particleSystem of this.particleSystems) {
          particleSystem.material.uniforms.time.value = time;
        }
        
        // Update dark pool materials
        for (const darkPool of this.darkPoolMasses) {
          darkPool.material.uniforms.time.value = time;
        }
        
        // Find the most prominent dark pool (highest volume)
        if (this.darkPoolMasses.length > 0) {
          let primaryDarkPool = this.darkPoolMasses[0];
          let highestVolume = primaryDarkPool.userData.darkPoolData.volume;
          
          for (let i = 1; i < this.darkPoolMasses.length; i++) {
            const volume = this.darkPoolMasses[i].userData.darkPoolData.volume;
            if (volume > highestVolume) {
              highestVolume = volume;
              primaryDarkPool = this.darkPoolMasses[i];
            }
          }
          
          // Update lens shader to focus on this dark pool
          // Convert 3D position to screen coordinates
          const vector = primaryDarkPool.position.clone();
          vector.project(this.camera);
          
          // Convert to normalized coordinates for shader (0 to 1)
          const x = (vector.x + 1) / 2;
          const y = (vector.y + 1) / 2;
          
          // Update lens shader uniforms
          if (this.lensPass) {
            this.lensPass.uniforms.center.value.set(x, y);
            
            // Modulate strength based on view angle and time
            const baseStrength = this.gravityStrength * (primaryDarkPool.userData.darkPoolData.volume / this.maxVolume);
            const pulseFactor = 0.8 + 0.2 * Math.sin(time * 0.5);
            this.lensPass.uniforms.strength.value = baseStrength * pulseFactor;
          }
          
          // Apply shader-based lens effects instead of geometry distortion
          // This is much more efficient and realistic looking
          
          // However, we'll still do some subtle geometry warping for visual effect
          this.candlesticks.children.forEach(child => {
            if (!child.position) return;
            
            // Calculate distance to primary dark pool
            const distanceToCenter = child.position.distanceTo(primaryDarkPool.position);
            if (distanceToCenter < 15) {
              // Calculate distortion factor - closer objects get more distorted
              const pullFactor = 1 - distanceToCenter / 15;
              
              // Only store original scale once
              if (!child.userData.originalScale) {
                child.userData.originalScale = child.scale.clone();
                child.userData.originalPosition = child.position.clone();
              }
              
              // Wobble effect based on time
              const wobble = Math.sin(time * 2 + child.position.x * 0.1) * 0.05;
              
              // Pull slightly toward the center based on distance
              if (child.userData.originalPosition) {
                const pullDirection = new THREE.Vector3().subVectors(
                  primaryDarkPool.position, 
                  child.userData.originalPosition
                ).normalize();
                
                // Apply pull with wobble
                child.position.copy(child.userData.originalPosition.clone());
                child.position.add(pullDirection.multiplyScalar(pullFactor * 0.5 * (1 + wobble)));
              }
              
              // Distort the scale 
              if (child.userData.originalScale) {
                const pulseScale = 1 + pullFactor * 0.3 * Math.sin(time * 3 + child.position.z * 0.2);
                child.scale.set(
                  child.userData.originalScale.x * (1 + pullFactor * 0.3),
                  child.userData.originalScale.y * pulseScale,
                  child.userData.originalScale.z * (1 + pullFactor * 0.3)
                );
              }
            } else if (child.userData.originalPosition) {
              // Reset position and scale when out of range
              child.position.copy(child.userData.originalPosition);
              if (child.userData.originalScale) {
                child.scale.copy(child.userData.originalScale);
              }
            }
          });
        }
      }

      setLensActive(active) {
        this.lensActive = active;
        showToast('info', 'Gravitational Lens', `Lens effect ${active ? 'activated' : 'deactivated'}`);
      }

      // VR mode with WebXR support
      enableVRMode() {
        showToast('info', 'VR Mode', 'Entering virtual reality mode.');
        
        if (!this.isReady) return;
        
        // Check if WebXR is supported by the browser
        if ('xr' in navigator) {
          // Check if VR is supported
          navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
            if (supported) {
              this.initWebXR();
            } else {
              showToast('warning', 'VR Not Supported', 'Your browser supports WebXR, but VR is not available');
            }
          });
        } else {
          showToast('error', 'WebXR Not Supported', 'Your browser does not support WebXR');
          // Fallback to fake VR experience (just move the camera to an immersive position)
          this.camera.position.set(0, 15, 0.1);
          this.controls.target.set(0, 10, -20);
          this.camera.lookAt(new THREE.Vector3(0, 10, -20));
        }
      }
      
      // Initialize WebXR for true VR experience
      initWebXR() {
        if (!this.renderer) return;
        
        try {
          // Enable XR
          this.renderer.xr.enabled = true;
          
          // Create VR button
          const vrButton = document.createElement('button');
          vrButton.style.position = 'absolute';
          vrButton.style.bottom = '20px';
          vrButton.style.left = '50%';
          vrButton.style.transform = 'translateX(-50%)';
          vrButton.style.padding = '10px 20px';
          vrButton.style.backgroundColor = 'var(--primary-color)';
          vrButton.style.color = 'white';
          vrButton.style.border = 'none';
          vrButton.style.borderRadius = '6px';
          vrButton.style.zIndex = '999';
          vrButton.textContent = 'ENTER VR';
          
          // WebXR session options
          const sessionOptions = {
            optionalFeatures: ['local-floor', 'bounded-floor']
          };
          
          // Set up XR session start and end
          vrButton.addEventListener('click', () => {
            navigator.xr.requestSession('immersive-vr', sessionOptions).then((session) => {
              this.renderer.xr.setSession(session);
              session.addEventListener('end', () => {
                vrButton.textContent = 'ENTER VR';
                showToast('info', 'VR Ended', 'Exited virtual reality mode');
              });
              vrButton.textContent = 'EXIT VR';
              
              // Set up controllers
              this.setupVRControllers(session);
            });
          });
          
          this.container.parentNode.appendChild(vrButton);
          
        } catch (error) {
          console.error('Error initializing WebXR:', error);
          showToast('error', 'VR Error', 'Failed to initialize VR mode: ' + error.message);
        }
      }
      
      // Set up VR controllers
      setupVRControllers(session) {
        // For complete implementation, we would:
        // 1. Create controller models
        // 2. Set up interaction rays
        // 3. Handle selection events
        // 4. Implement locomotion
        
        // This is a placeholder for those features
        console.log('VR controllers would be initialized here', session);
      }

      // Time-warp replay - animate through historical data
      timeWarpReplay() {
        showToast('info', 'Time-Warp', 'Initiating time-warp visualization.');
        
        if (!this.isReady || !this.data || this.data.length === 0) return;
        
        // Stop any existing animation
        if (this.timeWarpAnimation) {
          clearInterval(this.timeWarpAnimation);
          this.timeWarpAnimation = null;
        }
        
        // Create a copy of the data for animation
        const originalData = [...this.data];
        let visibleCount = 10; // Start with just a few candles
        const maxCount = originalData.length;
        let direction = 1; // 1 = forward, -1 = backward
        let speed = 300; // milliseconds between frames
        
        // Create animation controls overlay
        const controls = document.createElement('div');
        controls.className = 'time-warp-controls';
        controls.style.position = 'absolute';
        controls.style.bottom = '80px';
        controls.style.left = '50%';
        controls.style.transform = 'translateX(-50%)';
        controls.style.backgroundColor = 'rgba(26, 26, 46, 0.8)';
        controls.style.padding = '10px';
        controls.style.borderRadius = '6px';
        controls.style.zIndex = '30';
        controls.style.display = 'flex';
        controls.style.gap = '10px';
        controls.style.backdropFilter = 'blur(5px)';
        
        controls.innerHTML = `
          <button id="tw-slower"></button>
          <button id="tw-backward"></button>
          <button id="tw-pause"></button>
          <button id="tw-forward"></button>
          <button id="tw-faster"></button>
          <button id="tw-close"></button>
        `;
        
        this.container.parentNode.appendChild(controls);
        
        // Animation state
        let paused = false;
        
        // Animation function
        const animate = () => {
          if (paused) return;
          
          // Update visible count based on direction
          visibleCount += direction;
          
          // Loop if we reach the edges
          if (visibleCount > maxCount) {
            visibleCount = 10;
          } else if (visibleCount < 10) {
            visibleCount = maxCount;
          }
          
          // Get the visible slice of data
          const visibleData = originalData.slice(0, visibleCount);
          
          // Update the chart with the visible data
          this.data = visibleData;
          this.minPrice = Math.min(...visibleData.map(d => d.low));
          this.maxPrice = Math.max(...visibleData.map(d => d.high));
          this.maxVolume = Math.max(...visibleData.map(d => d.volume));
          this.renderCandlesticks();
        };
        
        // Start animation
        this.timeWarpAnimation = setInterval(animate, speed);
        
        // Control handlers
        document.getElementById('tw-slower').addEventListener('click', () => {
          speed += 100;
          if (speed > 1000) speed = 1000;
          clearInterval(this.timeWarpAnimation);
          this.timeWarpAnimation = setInterval(animate, speed);
        });
        
        document.getElementById('tw-faster').addEventListener('click', () => {
          speed -= 100;
          if (speed < 100) speed = 100;
          clearInterval(this.timeWarpAnimation);
          this.timeWarpAnimation = setInterval(animate, speed);
        });
        
        document.getElementById('tw-backward').addEventListener('click', () => {
          direction = -1;
        });
        
        document.getElementById('tw-forward').addEventListener('click', () => {
          direction = 1;
        });
        
        document.getElementById('tw-pause').addEventListener('click', () => {
          paused = !paused;
          document.getElementById('tw-pause').textContent = paused ? '' : '';
        });
        
        document.getElementById('tw-close').addEventListener('click', () => {
          clearInterval(this.timeWarpAnimation);
          this.timeWarpAnimation = null;
          controls.remove();
          
          // Restore original data
          this.data = originalData;
          this.minPrice = Math.min(...originalData.map(d => d.low));
          this.maxPrice = Math.max(...originalData.map(d => d.high));
          this.maxVolume = Math.max(...originalData.map(d => d.volume));
          this.renderCandlesticks();
        });
      }
    }

    // Auth & UI code
    loginButton.addEventListener('click', () => {
      authModal.classList.add('visible');
    });

    loginTab.addEventListener('click', () => {
      loginTab.classList.add('active');
      signupTab.classList.remove('active');
      loginForm.style.display = 'flex';
      signupForm.style.display = 'none';
    });

    signupTab.addEventListener('click', () => {
      signupTab.classList.add('active');
      loginTab.classList.remove('active');
      signupForm.style.display = 'flex';
      loginForm.style.display = 'none';
    });

    loginForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const email = document.getElementById('login-email').value;
      const password = document.getElementById('login-password').value;
      const msg = document.getElementById('login-message');
      msg.textContent = 'Logging in...';
      try {
        const resp = await signIn(email, password);
        if (resp.error) {
          msg.textContent = resp.error.message;
          return;
        }
        msg.textContent = 'Login successful!';
        setTimeout(() => {
          authModal.classList.remove('visible');
          updateUserInterface(true);
        }, 1000);
      } catch (err) {
        msg.textContent = err.message || 'Error logging in.';
      }
    });

    signupForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const email = document.getElementById('signup-email').value;
      const password = document.getElementById('signup-password').value;
      const msg = document.getElementById('signup-message');
      msg.textContent = 'Creating account...';
      try {
        const resp = await signUp(email, password);
        if (resp.error) {
          msg.textContent = resp.error.message;
          return;
        }
        msg.textContent = 'Account created! You can now log in.';
        setTimeout(() => {
          loginTab.click();
        }, 2000);
      } catch (err) {
        msg.textContent = err.message || 'Error creating account.';
      }
    });

    // Time-warp & VR & Lens toggles
    timeWarpBtn?.addEventListener('click', () => {
      if (chart) chart.timeWarpReplay();
    });
    vrModeBtn?.addEventListener('click', () => {
      if (chart) chart.enableVRMode();
    });
    lensBtn?.addEventListener('click', () => {
      if (!chart) return;
      chart.setLensActive(!chart.lensActive);
    });

    // Add these new button handlers
    indicatorBtn?.addEventListener('click', () => {
      showToast('info', 'Indicators', 'Technical indicator selector will appear here.');
    });
    comparisonBtn?.addEventListener('click', () => {
      showToast('info', 'Compare Assets', 'Asset comparison tool will appear here.');
    });

    function updateUserInterface(isLoggedIn) {
      if (isLoggedIn) {
        loginButton.style.display = 'none';
        userProfile.style.display = 'flex';
        loadAllPanels();
      } else {
        loginButton.style.display = 'block';
        userProfile.style.display = 'none';
      }
    }

    // Asynchronously load all panels
    async function loadAllPanels() {
      // Load panels in parallel for better performance
      Promise.all([
        loadAIPredictions(),
        loadSocialSentiment(),
        loadMarketNews()
      ]).then(() => {
        console.log('All panels loaded');
      }).catch(err => {
        console.error('Error loading panels:', err);
      });
    }

    // Load AI predictions independently
    async function loadAIPredictions() {
      try {
        // Reset to skeleton loader state
        aiContent.innerHTML = `
          <div class="skeleton skeleton-heading"></div>
          <div class="skeleton skeleton-text"></div>
          <div class="skeleton skeleton-text"></div>
          <div class="skeleton skeleton-text-short"></div>
        `;

        // Fetch predictions
        const { data: aiData, error: aiErr } = await getPrediction(currentSymbol, '7d');

        if (aiErr) {
          aiContent.textContent = `Error: Disabled`;
          // Mark AI as loaded even on error
          updateLoadingProgress('ai', true);
          return;
        }

        if (aiData) {
          aiContent.innerHTML = `
            <div>Target Price: $${aiData.target_price}</div>
            <div>Confidence: ${aiData.confidence}%</div>
            <div>Resistance: ${aiData.resistance || 'N/A'}</div>
            <div>Support: ${aiData.support || 'N/A'}</div>
            <div><em>${aiData.reasoning || ''}</em></div>
          `;
        } else {
          aiContent.textContent = 'No AI prediction found.';
        }

        // Mark AI as loaded
        updateLoadingProgress('ai', true);

      } catch (err) {
        console.error('Error loading AI predictions:', err);
        aiContent.textContent = 'Error loading predictions.';
        // Mark AI as loaded even on error
        updateLoadingProgress('ai', true);
      }
    }

    // Load social sentiment independently
    async function loadSocialSentiment() {
      try {
        // Reset to skeleton loader state
        sentimentContent.innerHTML = `
          <div class="skeleton skeleton-heading"></div>
          <div class="skeleton skeleton-text"></div>
          <div class="skeleton skeleton-text"></div>
          <div class="skeleton skeleton-text-short"></div>
        `;
        
        // Fetch data
        const { data: sentData, error: sentErr } = await getSocialSentiment(currentSymbol);
        
        if (sentErr) {
          sentimentContent.textContent = `Error: ${sentErr}`;
          return;
        }
        
        if (sentData) {
          sentimentContent.innerHTML = `
            <div>Score: ${sentData.score}</div>
            <div>Bullish: ${sentData.bullish}%</div>
            <div>Bearish: ${sentData.bearish}%</div>
            <div>Neutral: ${sentData.neutral}%</div>
            <div>Total Mentions: ${sentData.total_mentions}</div>
          `;
        } else {
          sentimentContent.textContent = 'No sentiment data found.';
        }
      } catch (err) {
        console.error('Error loading sentiment data:', err);
        sentimentContent.textContent = 'Error loading sentiment data.';
      }
    }

    // Load market news independently
    async function loadMarketNews() {
      try {
        // Reset to skeleton loader state
        newsContent.innerHTML = `
          <div class="skeleton skeleton-heading"></div>
          <div class="skeleton skeleton-text"></div>
          <div class="skeleton skeleton-text"></div>
          <div class="skeleton skeleton-text-short"></div>
          <div style="margin-top: 15px;"></div>
          <div class="skeleton skeleton-heading"></div>
          <div class="skeleton skeleton-text"></div>
          <div class="skeleton skeleton-text-short"></div>
        `;
        
        // Fetch news
        const { data: newsData, error: newsErr } = await getNews(currentSymbol, 3);
        
        if (newsErr) {
          newsContent.textContent = `Error: ${newsErr}`;
          return;
        }
        
        if (newsData && newsData.length > 0) {
          const html = newsData.map(n => `
            <div style="margin-bottom:10px;">
              <strong>${n.title}</strong><br/>
              <em>${n.source} | ${new Date(n.published_at).toLocaleString()}</em><br/>
              <small>${n.summary || ''}</small>
            </div>
          `).join('');
          newsContent.innerHTML = html;
        } else {
          newsContent.textContent = 'No news found.';
        }
      } catch (err) {
        console.error('Error loading news:', err);
        newsContent.textContent = 'Error loading news.';
      }
    }

    // Loading chart data
    async function loadChartData() {
      if (chartLoading) {
        chartLoading.classList.remove('loaded');
      }

      try {
        // Load Attana CSV data if symbol is ATANA
        if (currentSymbol === 'ATANA' || currentSymbol === 'ATTANA') {
          const attanaData = await loadAttanaCSV();
          if (attanaData && attanaData.length > 0) {
            updateLoadingProgress('connect', true);
            showToast('success', 'Attana Data Loaded', `Loaded ${attanaData.length} candlesticks`);
            return attanaData;
          }
        }

        const rawData = await getMarketData(currentSymbol, currentTimeframe);

        if (rawData.error) {
          showToast('error', 'Data Error', `Failed to load market data: ${rawData.error}`);
          return generateMockData();
        }

        if (rawData && rawData.data && rawData.data.length > 0) {
          updateLoadingProgress('connect', true);
          return convertCandlestickData(rawData.data);
        }

        // Fallback to mock data
        updateLoadingProgress('connect', true);
        return generateMockData();

      } catch (err) {
        console.error('Error loading market data:', err);
        showToast('warning', 'Data Warning', 'Using mock data due to connection issue');
        updateLoadingProgress('connect', true);
        return generateMockData();
      }
    }

    // Load Attana CSV data
    async function loadAttanaCSV() {
      try {
        const response = await fetch('/attana_ohlc.csv');
        const csvText = await response.text();
        const lines = csvText.trim().split('\n');
        const data = [];

        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].replace(/"/g, '');
          const values = line.split(',');

          if (values.length >= 5) {
            let dateStr = values[0].trim().replace('/2025', '/2024');
            const date = new Date(dateStr);
            const timestamp = date.getTime();

            const close = parseFloat(values[1].replace(',', '.'));
            const open = parseFloat(values[2].replace(',', '.'));
            const high = parseFloat(values[3].replace(',', '.'));
            const low = parseFloat(values[4].replace(',', '.'));

            let volume = 1000000;
            if (values.length >= 6 && values[5].trim() !== '') {
              const volStr = values[5].trim();
              if (volStr.endsWith('M')) {
                volume = parseFloat(volStr.replace('M', '').replace(',', '.')) * 1000000;
              } else if (volStr.endsWith('K')) {
                volume = parseFloat(volStr.replace('K', '').replace(',', '.')) * 1000;
              } else {
                volume = parseFloat(volStr.replace(',', '.')) || 1000000;
              }
            }

            if (!isNaN(timestamp) && !isNaN(open) && !isNaN(high) && !isNaN(low) && !isNaN(close)) {
              data.push({ timestamp, open, high, low, close, volume });
            }
          }
        }

        return data.sort((a, b) => a.timestamp - b.timestamp);
      } catch (error) {
        console.error('Error loading Attana CSV:', error);
        return null;
      }
    }

    // Generate fallback data
    function generateMockData(count = 50) {
      const data = [];
      let price = 55000 + Math.random() * 5000;
      const now = Date.now();
      const oneDay = 24 * 60 * 60 * 1000;
      for (let i=0; i<count; i++) {
        const change = (Math.random() - 0.5) * 2;
        const open = price;
        price = open + open * change * 0.02;
        const high = Math.max(open, price) + Math.random() * Math.abs(price - open) * 0.5;
        const low = Math.min(open, price) - Math.random() * Math.abs(price - open) * 0.5;
        const close = price;
        const volume = Math.floor(Math.random() * 100000) + 10000;
        const timestamp = now - (count - i)*oneDay;
        data.push({ timestamp, open, high, low, close, volume });
      }
      return data;
    }

    // Initialize watchlist
    function initializeWatchlist() {
      const watchlistItems = document.querySelectorAll('.stock-item');
      watchlistItems.forEach(item => {
        item.addEventListener('click', function() {
          // Remove active class from all items
          watchlistItems.forEach(i => i.classList.remove('active'));
          
          // Add active class to clicked item
          this.classList.add('active');
          
          // Get symbol from clicked item
          const symbol = this.querySelector('.stock-symbol').textContent;
          
          // Update current symbol and reload data
          if (symbol !== currentSymbol) {
            currentSymbol = symbol;
            showToast('info', 'Symbol Changed', `Loading data for ${symbol}`);
            
            // Reload all data
            loadChartData().then(data => {
              if (chart) chart.setData(data);
              loadAllPanels();
            });
          }
        });
      });
    }

    // Save user preferences and watchlist
    function saveUserPreferences() {
      // Get user preferences
      const preferences = {
        theme: 'dark', // Could be configurable
        currentSymbol: currentSymbol,
        currentTimeframe: currentTimeframe,
        sidebarCollapsed: leftSidebar.classList.contains('collapsed'),
        panelsCollapsed: rightPanels.classList.contains('collapsed')
      };
      
      // Save to localStorage for non-logged in users
      localStorage.setItem('moonai_preferences', JSON.stringify(preferences));
      
      // If user is logged in, could save to Supabase
      if (supabaseClient?.auth?.user()) {
        // Example of saving to user-specific table
        // This would require a 'user_preferences' table in Supabase
        supabaseClient
          .from('user_preferences')
          .upsert({
            user_id: supabaseClient.auth.user().id,
            preferences: preferences
          })
          .then(result => {
            if (result.error) {
              console.error('Error saving preferences:', result.error);
            }
          });
      }
      
      showToast('success', 'Preferences Saved', 'Your settings have been saved');
    }
    
    // Load user preferences
    async function loadUserPreferences() {
      let preferences = null;
      
      // Try loading from Supabase if logged in
      if (supabaseClient?.auth?.user()) {
        try {
          const { data, error } = await supabaseClient
            .from('user_preferences')
            .select('preferences')
            .eq('user_id', supabaseClient.auth.user().id)
            .single();
            
          if (!error && data) {
            preferences = data.preferences;
          }
        } catch (err) {
          console.error('Error loading preferences from Supabase:', err);
        }
      }
      
      // Fall back to localStorage if not found in Supabase
      if (!preferences) {
        const savedPrefs = localStorage.getItem('moonai_preferences');
        if (savedPrefs) {
          try {
            preferences = JSON.parse(savedPrefs);
          } catch (err) {
            console.error('Error parsing saved preferences:', err);
          }
        }
      }
      
      // Apply preferences if found
      if (preferences) {
        // Apply symbol and timeframe
        if (preferences.currentSymbol) {
          currentSymbol = preferences.currentSymbol;
        }
        
        if (preferences.currentTimeframe) {
          currentTimeframe = preferences.currentTimeframe;
          // Update UI
          timeframeButtons.forEach(btn => {
            if (btn.getAttribute('data-timeframe') === currentTimeframe) {
              btn.classList.add('active');
            } else {
              btn.classList.remove('active');
            }
          });
        }
        
        // Apply sidebar and panel states
        if (preferences.sidebarCollapsed) {
          leftSidebar.classList.add('collapsed');
          sidebarToggle.classList.add('collapsed');
          sidebarToggle.innerHTML = '<span></span>';
        }
        
        if (preferences.panelsCollapsed) {
          rightPanels.classList.add('collapsed');
          panelsToggle.classList.add('collapsed');
          document.querySelector('.platform-container')?.classList.add('right-panel-collapsed');
          // Update tooltip only (don't replace SVG with innerHTML)
          const tooltip = panelsToggle.querySelector('.tv-tooltip');
          if (tooltip) tooltip.textContent = 'Show panel';
          panelsToggle.setAttribute('aria-expanded', 'false');
        }
      }
    }
    
    // Set up real-time updates for chart
    function setupRealTimeUpdates() {
      // Unsubscribe from any existing subscription
      if (window._marketDataSubscription) {
        window._marketDataSubscription();
        window._marketDataSubscription = null;
      }
      
      // Set up new subscription
      try {
        window._marketDataSubscription = subscribeToMarketData(currentSymbol, (payload) => {
          console.log('Real-time update received:', payload);
          
          // Process the update based on type
          if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
            const newData = payload.new;
            
            if (!newData) return;
            
            // Convert to correct format
            const candleData = {
              timestamp: new Date(newData.timestamp).getTime(),
              open: parseFloat(newData.open),
              high: parseFloat(newData.high),
              low: parseFloat(newData.low),
              close: parseFloat(newData.close),
              volume: parseInt(newData.volume, 10)
            };
            
            // Check if this is an update to an existing candle or a new one
            const existingIndex = chart.data.findIndex(d => 
              d.timestamp === candleData.timestamp
            );
            
            // Update UI based on whether this is new or updated data
            if (existingIndex >= 0) {
              // Update existing candle
              chart.data[existingIndex] = candleData;
              showToast('info', 'Data Updated', `${currentSymbol} candle updated`);
            } else {
              // Add new candle
              chart.data.push(candleData);
              showToast('info', 'New Data', `New ${currentSymbol} candle received`);
              
              // Sort data by timestamp to keep chronological order
              chart.data.sort((a, b) => a.timestamp - b.timestamp);
            }
            
            // Update chart
            chart.minPrice = Math.min(...chart.data.map(d => d.low));
            chart.maxPrice = Math.max(...chart.data.map(d => d.high));
            chart.maxVolume = Math.max(...chart.data.map(d => d.volume));
            chart.renderCandlesticks();
            
            // Also update AI predictions and sentiment if available
            if (Math.random() > 0.7) { // Only occasionally refresh these
              loadAIPredictions();
              loadSocialSentiment();
            }
          }
        });
        
        console.log(`Real-time updates enabled for ${currentSymbol}`);
      } catch (err) {
        console.error('Error setting up real-time updates:', err);
      }
    }
    
    // Enhance rendering with instancing for better performance
    function setupInstancedRendering(chart) {
      if (!chart || !chart.isReady || typeof THREE === 'undefined') return;
      
      try {
        // Save original render method for fallback
        const originalRender = chart.renderCandlesticks;
        
        // Create enhanced instanced rendering method
        chart.renderCandlesticksInstanced = function() {
          // Clear existing
          while (this.candlesticks.children.length > 0) {
            this.candlesticks.remove(this.candlesticks.children[0]);
          }
          while (this.volumeBars.children.length > 0) {
            this.volumeBars.remove(this.volumeBars.children[0]);
          }
          
          if (!this.data || this.data.length === 0) return;
          
          const priceRange = this.maxPrice - this.minPrice;
          const scaleFactor = 20 / priceRange;
          
          // Create instanced candlestick bodies
          const candleCount = this.data.length;
          const bodyGeometry = new THREE.BoxGeometry(0.8, 1, 0.8);
          const bullishMaterial = new THREE.MeshStandardMaterial({
            color: 0x00b894,
            metalness: 0.2,
            roughness: 0.5
          });
          const bearishMaterial = new THREE.MeshStandardMaterial({
            color: 0xff7675,
            metalness: 0.2,
            roughness: 0.5
          });
          
          // Create instanced meshes for bull and bear candles
          const bullishInstancedMesh = new THREE.InstancedMesh(
            bodyGeometry,
            bullishMaterial,
            candleCount
          );
          const bearishInstancedMesh = new THREE.InstancedMesh(
            bodyGeometry,
            bearishMaterial,
            candleCount
          );
          
          // Set initial visibility to false (we'll only show the ones we need)
          bullishInstancedMesh.count = 0;
          bearishInstancedMesh.count = 0;
          
          // Track instance counts
          let bullishCount = 0;
          let bearishCount = 0;
          
          // Create transform matrix for each instance
          const matrix = new THREE.Matrix4();
          const position = new THREE.Vector3();
          const quaternion = new THREE.Quaternion();
          const scale = new THREE.Vector3(1, 1, 1);
          
          // Create line segments for wicks
          const wickPositions = [];
          const wickMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
          
          // Create volume bars data
          const volumePositions = [];
          const volumeColors = [];
          
          // Process each candle
          this.data.forEach((candle, index) => {
            const isBullish = candle.close >= candle.open;
            const bodyHeight = Math.abs(candle.open - candle.close) * scaleFactor;
            const bodyBottom = Math.min(candle.open, candle.close);
            const bodyPosition = (bodyBottom - this.minPrice) * scaleFactor + bodyHeight / 2;
            
            // Position for this candle
            position.set(index * 1.2, bodyPosition, 0);
            
            // Scale for this candle
            scale.set(1, bodyHeight, 1);
            
            // Update the transform matrix
            matrix.compose(position, quaternion, scale);
            
            // Apply the matrix to the correct instanced mesh
            if (isBullish) {
              bullishInstancedMesh.setMatrixAt(bullishCount, matrix);
              bullishCount++;
            } else {
              bearishInstancedMesh.setMatrixAt(bearishCount, matrix);
              bearishCount++;
            }
            
            // Create wick vertices
            const wickTop = (candle.high - this.minPrice) * scaleFactor;
            const wickBottom = (candle.low - this.minPrice) * scaleFactor;
            wickPositions.push(
              index * 1.2, wickBottom, 0,
              index * 1.2, wickTop, 0
            );
            
            // Create volume bar data
            const volumeHeight = (candle.volume / this.maxVolume) * 10;
            volumePositions.push(
              index * 1.2 - 0.35, 0, -3,
              index * 1.2 + 0.35, 0, -3,
              index * 1.2 + 0.35, volumeHeight, -3,
              
              index * 1.2 - 0.35, 0, -3,
              index * 1.2 + 0.35, volumeHeight, -3,
              index * 1.2 - 0.35, volumeHeight, -3
            );
            
            // Color for volume bars
            const color = isBullish ? 
              new THREE.Color(0x00b894) : 
              new THREE.Color(0xff7675);
              
            for (let i = 0; i < 6; i++) {
              volumeColors.push(color.r, color.g, color.b);
            }
          });
          
          // Update instanced mesh counts
          bullishInstancedMesh.count = bullishCount;
          bearishInstancedMesh.count = bearishCount;
          
          // Update instance matrices
          bullishInstancedMesh.instanceMatrix.needsUpdate = true;
          bearishInstancedMesh.instanceMatrix.needsUpdate = true;
          
          // Add instanced meshes to scene
          this.candlesticks.add(bullishInstancedMesh);
          this.candlesticks.add(bearishInstancedMesh);
          
          // Create and add wicks
          const wickGeometry = new THREE.BufferGeometry();
          wickGeometry.setAttribute('position', new THREE.Float32BufferAttribute(wickPositions, 3));
          const wicks = new THREE.LineSegments(wickGeometry, wickMaterial);
          this.candlesticks.add(wicks);
          
          // Create and add volume bars
          const volumeGeometry = new THREE.BufferGeometry();
          volumeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(volumePositions, 3));
          volumeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(volumeColors, 3));
          const volumeMaterial = new THREE.MeshBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: 0.5
          });
          const volumeBars = new THREE.Mesh(volumeGeometry, volumeMaterial);
          this.volumeBars.add(volumeBars);
          
          // Position the groups
          this.candlesticks.position.x = -this.data.length * 0.6;
          this.volumeBars.position.x = -this.data.length * 0.6;
        };
        
        // Try to use instanced rendering, fall back to original if it fails
        try {
          chart.renderCandlesticks = chart.renderCandlesticksInstanced;
          console.log('Using instanced rendering for better performance');
        } catch (renderError) {
          console.error('Error setting up instanced rendering, using fallback:', renderError);
          chart.renderCandlesticks = originalRender;
        }
      } catch (err) {
        console.error('Error setting up instanced rendering:', err);
      }
    }

    // Initialize Voice Assistant
    function initializeVoiceAssistant() {
      const voiceAssistantIcon = document.getElementById('voice-assistant-icon');
      const voiceAssistantPanel = document.getElementById('voice-assistant-panel');
      const voicePanelClose = document.getElementById('voice-panel-close');
      const voiceInput = document.getElementById('voice-input');
      const voiceMicButton = document.getElementById('voice-mic-button');
      const voicePanelContent = document.getElementById('voice-panel-content');
      
      // Show/hide panel when clicking the icon
      voiceAssistantIcon.addEventListener('click', () => {
        voiceAssistantPanel.classList.toggle('active');
      });
      
      // Close the panel
      voicePanelClose.addEventListener('click', () => {
        voiceAssistantPanel.classList.remove('active');
      });
      
      // Handle text input
      voiceInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const message = voiceInput.value.trim();
          if (message) {
            addMessageToChat('user', message);
            voiceInput.value = '';
            
            // Process the command
            processVoiceCommand(message);
          }
        }
      });
      
      // Handle microphone button
      voiceMicButton.addEventListener('click', () => {
        if (speechRecognition) {
          try {
            // Show recording indicator
            voiceMicButton.style.backgroundColor = '#ff7675';
            
            // Start listening
            speechRecognition.start();
            
            // Handle the result
            speechRecognition.onresult = (event) => {
              const transcript = event.results[0][0].transcript;
              addMessageToChat('user', transcript);
              
              // Process the command
              processVoiceCommand(transcript);
            };
            
            // Reset on end
            speechRecognition.onend = () => {
              voiceMicButton.style.backgroundColor = '';
            };
            
            // Handle errors
            speechRecognition.onerror = (event) => {
              console.error('Speech recognition error:', event.error);
              voiceMicButton.style.backgroundColor = '';
              addMessageToChat('assistant', 'Sorry, I couldn\'t understand that. Please try again.');
            };
            
          } catch (err) {
            console.error('Error starting speech recognition:', err);
            voiceMicButton.style.backgroundColor = '';
            addMessageToChat('assistant', 'Sorry, speech recognition failed. Please type your request instead.');
          }
        } else {
          addMessageToChat('assistant', 'Sorry, speech recognition is not supported in your browser.');
        }
      });
      
      // Add message to the chat
      function addMessageToChat(type, text) {
        const messageDiv = document.createElement('div');
        messageDiv.className = type === 'user' ? 'user-message' : 'assistant-message';
        messageDiv.textContent = text;
        
        voicePanelContent.appendChild(messageDiv);
        voicePanelContent.scrollTop = voicePanelContent.scrollHeight;
        
        // If it's an assistant message, also speak it if speech synthesis is available
        if (type === 'assistant' && speechSynthesis) {
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.rate = 1.0;
          utterance.pitch = 1.0;
          speechSynthesis.speak(utterance);
        }
      }
      
      // Process voice commands
      function processVoiceCommand(command) {
        command = command.toLowerCase();
        
        // Handle lens commands
        if (command.includes('gravitational lens') || command.includes('gravity lens')) {
          if (command.includes('on') || command.includes('enable') || command.includes('activate')) {
            if (chart) {
              chart.setLensActive(true);
              addMessageToChat('assistant', 'Gravitational lens effect activated.');
            }
          } else if (command.includes('off') || command.includes('disable') || command.includes('deactivate')) {
            if (chart) {
              chart.setLensActive(false);
              addMessageToChat('assistant', 'Gravitational lens effect deactivated.');
            }
          } else {
            if (chart) {
              chart.setLensActive(!chart.lensActive);
              addMessageToChat('assistant', `Gravitational lens effect ${chart.lensActive ? 'activated' : 'deactivated'}.`);
            }
          }
          return;
        }
        
        // Handle time-warp commands
        if (command.includes('time warp') || command.includes('timewarp') || command.includes('rewind') || command.includes('replay')) {
          if (chart) {
            chart.timeWarpReplay();
            addMessageToChat('assistant', 'Initiating time-warp visualization.');
          }
          return;
        }
        
        // Handle VR commands
        if (command.includes('vr') || command.includes('virtual reality')) {
          if (chart) {
            chart.enableVRMode();
            addMessageToChat('assistant', 'Entering virtual reality mode.');
          }
          return;
        }
        
        // Handle symbol change commands
        if (command.includes('show') || command.includes('load') || command.includes('display')) {
          const symbols = ['aapl', 'msft', 'tsla', 'nvda', 'amzn', 'googl'];
          
          for (const symbol of symbols) {
            if (command.includes(symbol)) {
              // Update current symbol and reload data
              if (symbol.toUpperCase() !== currentSymbol) {
                currentSymbol = symbol.toUpperCase();
                addMessageToChat('assistant', `Loading data for ${currentSymbol}.`);
                
                // Update active class in the watchlist
                const watchlistItems = document.querySelectorAll('.stock-item');
                watchlistItems.forEach(item => {
                  const itemSymbol = item.querySelector('.stock-symbol').textContent;
                  if (itemSymbol === currentSymbol) {
                    item.classList.add('active');
                  } else {
                    item.classList.remove('active');
                  }
                });
                
                // Reload data
                loadChartData().then(data => {
                  if (chart) chart.setData(data);
                  loadAllPanels();
                });
              } else {
                addMessageToChat('assistant', `Already displaying ${currentSymbol}.`);
              }
              return;
            }
          }
        }
        
        // Handle timeframe change commands
        if (command.includes('timeframe') || command.includes('time frame') || command.includes('interval')) {
          const timeframes = {
            'one day': '1d',
            'day': '1d',
            'week': '1w',
            'one week': '1w',
            'month': '1m',
            'one month': '1m',
            'three months': '3m',
            'three month': '3m',
            'year': '1y',
            'one year': '1y',
            'all': 'all',
            'all time': 'all'
          };
          
          for (const [key, value] of Object.entries(timeframes)) {
            if (command.includes(key)) {
              if (value !== currentTimeframe) {
                currentTimeframe = value;
                addMessageToChat('assistant', `Changing timeframe to ${key}.`);
                
                // Update active class in the timeframe buttons
                const timeframeButtons = document.querySelectorAll('.timeframe-button');
                timeframeButtons.forEach(btn => {
                  if (btn.getAttribute('data-timeframe') === currentTimeframe) {
                    btn.classList.add('active');
                  } else {
                    btn.classList.remove('active');
                  }
                });
                
                // Reload data with new timeframe
                loadChartData().then(data => {
                  if (chart) chart.setData(data);
                });
              } else {
                addMessageToChat('assistant', `Already showing ${key} timeframe.`);
              }
              return;
            }
          }
        }
        
        // Handle generic or unrecognized commands
        addMessageToChat('assistant', 'You can ask me to:\n- Change symbols (e.g., "Show AAPL")\n- Change timeframes (e.g., "Set timeframe to 1 week")\n- Toggle features (e.g., "Activate gravitational lens")\n- Start time-warp or VR mode');
      }
    }
    
    // Initialize Custom Indicators Editor
    function initializeCustomIndicators() {
      const indicatorModal = document.getElementById('custom-indicator-modal');
      const indicatorClose = document.getElementById('indicator-modal-close');
      const indicatorCancel = document.getElementById('indicator-cancel');
      const indicatorSave = document.getElementById('indicator-save');
      
      // Create an "Add Custom Indicator" button in the toolbar
      const toolbarGroup = document.querySelector('.toolbar-group:last-child');
      const indicatorBtn = document.createElement('button');
      indicatorBtn.className = 'control-button';
      indicatorBtn.id = 'custom-indicator-btn';
      indicatorBtn.textContent = 'Custom';
      indicatorBtn.setAttribute('data-tooltip', 'Create and manage custom indicators');
      toolbarGroup.appendChild(indicatorBtn);
      
      // Show the modal when clicking the button
      indicatorBtn.addEventListener('click', () => {
        indicatorModal.classList.add('visible');
      });
      
      // Close the modal
      indicatorClose.addEventListener('click', () => {
        indicatorModal.classList.remove('visible');
      });
      
      indicatorCancel.addEventListener('click', () => {
        indicatorModal.classList.remove('visible');
      });
      
      // Handle save button
      indicatorSave.addEventListener('click', () => {
        const name = document.getElementById('indicator-name').value.trim();
        const script = document.getElementById('indicator-script').value.trim();
        const color = document.getElementById('indicator-color').value;
        const width = document.getElementById('indicator-width').value;
        const style = document.getElementById('indicator-style').value;
        
        // Validate inputs
        if (!name || !script) {
          showToast('error', 'Validation Error', 'Name and script are required');
          return;
        }
        
        // Create a custom indicator object
        const indicator = {
          name,
          script,
          settings: {
            color,
            width: parseInt(width, 10),
            style
          },
          active: true
        };
        
        // Save indicator (in real app, would save to database)
        saveCustomIndicator(indicator);
        
        // Close modal
        indicatorModal.classList.remove('visible');
        
        // Show success message
        showToast('success', 'Indicator Saved', `Custom indicator "${name}" has been saved`);
      });
      
      // Function to save a custom indicator
      function saveCustomIndicator(indicator) {
        // In a real app, would save to Supabase or localStorage
        // For now, we'll just add it to a global array
        
        // Initialize the array if it doesn't exist
        if (!window.customIndicators) {
          window.customIndicators = [];
        }
        
        // Check if indicator already exists (update it) or add new
        const existingIndex = window.customIndicators.findIndex(i => i.name === indicator.name);
        if (existingIndex >= 0) {
          window.customIndicators[existingIndex] = indicator;
        } else {
          window.customIndicators.push(indicator);
        }
        
        // In a real app, also implement applying the indicator to the chart
        console.log('Custom indicators:', window.customIndicators);

        // Try to apply the indicator to the chart if it's active
        if (indicator.active && chart) {
          try {
            // Create a function from the script
            const indicatorFn = new Function('data', script);
            
            // Apply to chart data (placeholder - real implementation would be more complex)
            const result = indicatorFn(chart.data);
            console.log('Indicator result:', result);
            
            // Example: Show the indicator in the chart (real implementation would be more specific)
            showToast('info', 'Indicator Applied', `Applied "${name}" to the chart`);
          } catch (error) {
            console.error('Error applying indicator:', error);
            showToast('error', 'Script Error', `Error in indicator script: ${error.message}`);
          }
        }
      }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      const container = document.getElementById('chart-container');
      try {
        // Create chart
        chart = new CandlestickChart(container);
        
        // Initialize watchlist
        initializeWatchlist();
        
        // Mark first task as complete
        updateLoadingProgress('initialize', true);
        
        // Load user preferences
        await loadUserPreferences();
        
        // Set up performance enhancements
        setTimeout(() => setupInstancedRendering(chart), 1000);
        
        // Load data
        const marketData = await loadChartData();
        chart.setData(marketData);
        
        // Set up real-time updates
        setupRealTimeUpdates();
        
        // Load panels asynchronously
        loadAllPanels();
        
        // Initialize voice assistant
        initializeVoiceAssistant();
        
        // Initialize custom indicators
        initializeCustomIndicators();

        // Initialize context menu
        initializeContextMenu();

        // Initialize Sidebar Controller (Enterprise-grade panel management)
        initializeSidebarController();

        // Initialize tab switching for panels
        initializePanelTabs();

        // Initialize detach button handlers
        initializeDetachButtons();

        // Check if user is logged in
        onAuthStateChange((event, session) => {
          updateUserInterface(!!session);
          // Reload preferences if user logs in/out
          loadUserPreferences();
        });
        
        // Press 'v' to toggle chart view
        document.addEventListener('keydown', (e) => {
          if (e.key === 'v') {
            chart.toggleView();
          } else if (e.key === 's') {
            // Save preferences with 's' key
            saveUserPreferences();
          }
        });
        
        // Add save button to header
        const userControls = document.querySelector('.user-controls');
        const saveButton = document.createElement('button');
        saveButton.className = 'platform-button secondary';
        saveButton.textContent = 'Save Settings';
        saveButton.addEventListener('click', saveUserPreferences);
        userControls.appendChild(saveButton);
        
      } catch (error) {
        console.error('Error initializing:', error);
        showToast('error', 'Initialization Error', error.message);

        // Still mark progress as complete to hide the loading screen
        updateLoadingProgress('initialize', true);
        updateLoadingProgress('connect', true);
        updateLoadingProgress('ai', true);
        updateLoadingProgress('chart', true);
      }
    });

    // TradingView-style Context Menu Handler
    function initializeContextMenu() {
      const contextMenu = document.getElementById('chart-context-menu');
      const chartContainer = document.getElementById('chart-container');

      // Show context menu on right-click
      chartContainer.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        contextMenu.style.left = `${e.clientX}px`;
        contextMenu.style.top = `${e.clientY}px`;
        contextMenu.classList.add('active');
      });

      // Hide menu on outside click
      document.addEventListener('click', (e) => {
        if (!contextMenu.contains(e.target)) {
          contextMenu.classList.remove('active');
        }
      });

      // Handle menu clicks
      contextMenu.addEventListener('click', (e) => {
        const item = e.target.closest('.context-menu-item');
        if (!item || item.classList.contains('submenu')) return;

        const action = item.getAttribute('data-action');
        if (action === 'auto-scale' && chart) chart.resetView();
        if (action === 'invert-scale' && chart) chart.scene.rotation.z = chart.scene.rotation.z ? 0 : Math.PI;

        contextMenu.classList.remove('active');
      });
    }

    // Lightweight Charts 2D Implementation
    let lightweightChart = null;
    let candlestickSeries = null;
    let volumeSeries = null;
    let currentView = '3d'; // '3d' or '2d'

    function initialize2DChart() {
      const container = document.getElementById('chart-2d-container');

      // Check if library is loaded
      if (typeof LightweightCharts === 'undefined') {
        showToast('error', 'Chart Error', 'Lightweight Charts library not loaded. Please refresh.');
        console.error('LightweightCharts not loaded');
        return;
      }

      // Create chart with TradingView styling
      lightweightChart = LightweightCharts.createChart(container, {
        width: container.clientWidth,
        height: container.clientHeight,
        layout: {
          background: { color: '#0f0f1a' },
          textColor: '#d1d4dc',
        },
        grid: {
          vertLines: { color: '#1a1a2e' },
          horzLines: { color: '#1a1a2e' },
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Normal,
        },
        rightPriceScale: {
          borderColor: '#2a2e39',
        },
        timeScale: {
          borderColor: '#2a2e39',
          timeVisible: true,
          secondsVisible: false,
        },
      });

      // Add candlestick series (using v3 API)
      candlestickSeries = lightweightChart.addCandlestickSeries({
        upColor: '#00b894',
        downColor: '#ff7675',
        borderDownColor: '#ff7675',
        borderUpColor: '#00b894',
        wickDownColor: '#ff7675',
        wickUpColor: '#00b894',
      });

      // Add volume series
      volumeSeries = lightweightChart.addHistogramSeries({
        color: '#26a69a',
        priceFormat: {
          type: 'volume',
        },
        priceScaleId: '',
        scaleMargins: {
          top: 0.8,
          bottom: 0,
        },
      });

      // Make chart responsive
      new ResizeObserver(() => {
        if (lightweightChart && currentView === '2d') {
          lightweightChart.applyOptions({
            width: container.clientWidth,
            height: container.clientHeight
          });
        }
      }).observe(container);
    }

    function load2DChartData(data) {
      if (!data || data.length === 0) return;

      // Convert data to Lightweight Charts format (needs YYYY-MM-DD format)
      const candlestickData = data
        .filter(d => {
          // Strict validation - all values must be valid numbers
          return d.timestamp &&
                 typeof d.open === 'number' && !isNaN(d.open) && d.open > 0 &&
                 typeof d.high === 'number' && !isNaN(d.high) && d.high > 0 &&
                 typeof d.low === 'number' && !isNaN(d.low) && d.low > 0 &&
                 typeof d.close === 'number' && !isNaN(d.close) && d.close > 0;
        })
        .map(d => {
          const date = new Date(d.timestamp);
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');

          return {
            time: `${year}-${month}-${day}`,
            open: d.open,
            high: d.high,
            low: d.low,
            close: d.close,
          };
        });

      const volumeData = data
        .filter(d => {
          // Validate volume exists and is a valid number
          return d.timestamp &&
                 d.volume &&
                 typeof d.volume === 'number' &&
                 !isNaN(d.volume) &&
                 d.volume > 0 &&
                 typeof d.close === 'number' &&
                 typeof d.open === 'number';
        })
        .map(d => {
          const date = new Date(d.timestamp);
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');

          return {
            time: `${year}-${month}-${day}`,
            value: d.volume,
            color: d.close >= d.open ? '#00b89433' : '#ff767533'
          };
        });

      // CRITICAL FIX: Sort and deduplicate (Lightweight Charts requires strict ascending order)
      candlestickData.sort((a, b) => new Date(a.time) - new Date(b.time));
      volumeData.sort((a, b) => new Date(a.time) - new Date(b.time));

      // Remove duplicates
      const uniqueCandles = [];
      const seenTimes = new Set();
      candlestickData.forEach(candle => {
        if (!seenTimes.has(candle.time)) {
          uniqueCandles.push(candle);
          seenTimes.add(candle.time);
        }
      });

      const uniqueVolume = [];
      const seenVolTimes = new Set();
      volumeData.forEach(vol => {
        if (!seenVolTimes.has(vol.time)) {
          uniqueVolume.push(vol);
          seenVolTimes.add(vol.time);
        }
      });

      console.log(`Fixed: ${candlestickData.length}  ${uniqueCandles.length} candles`);
      console.log('First:', uniqueCandles[0]);
      console.log('Last:', uniqueCandles[uniqueCandles.length - 1]);

      try {
        candlestickSeries.setData(uniqueCandles);
        volumeSeries.setData(uniqueVolume);
        console.log(' Chart loaded successfully');

        // Hide loading overlay
        const chartLoading = document.getElementById('chart-loading');
        if (chartLoading) {
          chartLoading.classList.add('loaded');
        }
      } catch (e) {
        console.error('Chart error:', e);
        showToast('error', 'Chart Error', e.message);
        return;
      }

      // Fit content to screen
      lightweightChart.timeScale().fitContent();
    }

    function toggleChartView() {
      const chart3D = document.getElementById('chart-container');
      const chart2D = document.getElementById('chart-2d-container');
      const toggleBtn = document.getElementById('view-toggle-btn');

      if (currentView === '3d') {
        // Switch to 2D
        chart3D.style.display = 'none';
        chart2D.style.display = 'block';
        currentView = '2d';
        toggleBtn.textContent = '2D View';
        toggleBtn.classList.add('active');

        // Initialize 2D chart if not done yet
        if (!lightweightChart) {
          initialize2DChart();
          // Load current data
          loadChartData().then(data => load2DChartData(data));
        }

        showToast('success', 'View Changed', 'Switched to professional 2D chart');
      } else {
        // Switch to 3D
        chart3D.style.display = 'block';
        chart2D.style.display = 'none';
        currentView = '3d';
        toggleBtn.textContent = '3D View';
        toggleBtn.classList.remove('active');

        showToast('success', 'View Changed', 'Switched to immersive 3D chart');
      }
    }

    // Add toggle button handler after DOM loads
    document.addEventListener('DOMContentLoaded', () => {
      const toggleBtn = document.getElementById('view-toggle-btn');
      if (toggleBtn) {
        toggleBtn.addEventListener('click', toggleChartView);
      }
    });

    // ============================================
    // ENTERPRISE SIDEBAR CONTROLLER INTEGRATION
    // ============================================

    /**
     * Initialize the enterprise-grade Sidebar Controller
     */
    function initializeSidebarController() {
      console.log('[Platform] Initializing Sidebar Controller...');

      // Get the widgetbar buttons
      const widgetbar = document.getElementById('widgetbar');
      if (!widgetbar) {
        console.warn('[Platform] Widgetbar not found');
        return;
      }

      // Panel configuration
      const panelConfig = {
        watchlist: { id: 'watchlist-panel', button: '[data-panel="watchlist"]' },
        alerts: { id: 'alerts-panel', button: '[data-panel="alerts"]' },
        signals: { id: 'signals-panel', button: '[data-panel="signals"]' },
        ai: { id: 'ai-combined-panel', button: '[data-panel="ai"]' },
        screener: { id: 'screener-panel', button: '[data-panel="screener"]' },
        pine: { id: 'pine-panel', button: '[data-panel="pine"]' },
        calendar: { id: 'calendar-panel', button: '[data-panel="calendar"]' },
        news: { id: 'news-panel', button: '[data-panel="news"]' },
        notifications: { id: 'notifications-panel', button: '[data-panel="notifications"]' },
        settings: { id: 'settings-panel', button: '[data-panel="settings"]' },
        help: { id: 'help-panel', button: '[data-panel="help"]' }
      };

      let activePanel = 'signals'; // Default active panel

      // Handle widgetbar button clicks
      widgetbar.addEventListener('click', (e) => {
        const button = e.target.closest('.tv-widgetbar-btn, [data-panel]');
        if (!button) return;

        const panelKey = button.dataset.panel;
        if (!panelKey || !panelConfig[panelKey]) return;

        // Toggle or switch panel
        if (activePanel === panelKey) {
          // Hide panel if already active
          hidePanel(panelKey);
          activePanel = null;
          button.classList.remove('active', 'tv-widgetbar-btn--active');
          button.setAttribute('aria-pressed', 'false');
        } else {
          // Hide current active panel
          if (activePanel) {
            hidePanel(activePanel);
            const oldButton = widgetbar.querySelector(`[data-panel="${activePanel}"]`);
            if (oldButton) {
              oldButton.classList.remove('active', 'tv-widgetbar-btn--active');
              oldButton.setAttribute('aria-pressed', 'false');
            }
          }

          // Show new panel
          showPanel(panelKey);
          activePanel = panelKey;
          button.classList.add('active', 'tv-widgetbar-btn--active');
          button.setAttribute('aria-pressed', 'true');
        }
      });

      // Show panel with animation
      function showPanel(panelKey) {
        const config = panelConfig[panelKey];
        if (!config) return;

        const panel = document.getElementById(config.id);
        if (!panel) return;

        // Hide all panels first
        Object.values(panelConfig).forEach(cfg => {
          const p = document.getElementById(cfg.id);
          if (p && p !== panel) {
            p.style.display = 'none';
          }
        });

        // Show the selected panel with animation
        panel.style.display = 'flex';
        panel.style.opacity = '0';
        panel.style.transform = 'translateX(20px)';

        requestAnimationFrame(() => {
          panel.style.transition = 'opacity 250ms cubic-bezier(0.4, 0, 0.2, 1), transform 250ms cubic-bezier(0.4, 0, 0.2, 1)';
          panel.style.opacity = '1';
          panel.style.transform = 'translateX(0)';
        });

        console.log(`[Sidebar] Showing panel: ${panelKey}`);
      }

      // Hide panel with animation
      function hidePanel(panelKey) {
        const config = panelConfig[panelKey];
        if (!config) return;

        const panel = document.getElementById(config.id);
        if (!panel) return;

        panel.style.transition = 'opacity 200ms cubic-bezier(0.4, 0, 0.2, 1), transform 200ms cubic-bezier(0.4, 0, 0.2, 1)';
        panel.style.opacity = '0';
        panel.style.transform = 'translateX(20px)';

        setTimeout(() => {
          panel.style.display = 'none';
        }, 200);
      }

      // Show default panel (signals)
      showPanel('signals');
      const signalsBtn = widgetbar.querySelector('[data-panel="signals"]');
      if (signalsBtn) {
        signalsBtn.classList.add('active', 'tv-widgetbar-btn--active');
        signalsBtn.setAttribute('aria-pressed', 'true');
      }

      console.log('[Platform] Sidebar Controller initialized');
    }

    /**
     * Initialize tab switching for multi-tab panels
     */
    function initializePanelTabs() {
      // AI Panel tabs
      document.querySelectorAll('.ai-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const tab = btn.dataset.tab;
          const panel = btn.closest('.panel');

          // Update tab buttons
          panel.querySelectorAll('.ai-tab-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          // Update tab content
          panel.querySelectorAll('.ai-tab-content').forEach(c => {
            c.style.display = c.dataset.tab === tab ? 'block' : 'none';
            c.classList.toggle('active', c.dataset.tab === tab);
          });
        });
      });

      // Screener tabs
      document.querySelectorAll('.screener-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const tab = btn.dataset.tab;
          const panel = btn.closest('.panel');

          // Update tab buttons
          panel.querySelectorAll('.screener-tab-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          // Could load different screener content based on tab
          console.log(`[Screener] Switched to ${tab} tab`);
        });
      });

      // News tabs
      document.querySelectorAll('.news-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const tab = btn.dataset.tab;
          const panel = btn.closest('.panel');

          // Update tab buttons
          panel.querySelectorAll('.news-tab-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          // Update tab content
          panel.querySelectorAll('.news-tab-content').forEach(c => {
            c.style.display = c.dataset.tab === tab ? 'block' : 'none';
            c.classList.toggle('active', c.dataset.tab === tab);
          });
        });
      });

      console.log('[Platform] Panel tabs initialized');
    }

    /**
     * Initialize detach button handlers
     */
    function initializeDetachButtons() {
      document.querySelectorAll('.panel-detach-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const panelKey = btn.dataset.panel;
          detachPanel(panelKey);
        });
      });

      // Link indicator click handlers
      document.querySelectorAll('.panel-link-indicator').forEach(indicator => {
        indicator.addEventListener('click', (e) => {
          e.stopPropagation();
          // Toggle through link colors
          const dot = indicator.querySelector('.panel-link-dot');
          const colors = ['blue', 'green', 'orange', 'purple', 'master', 'none'];
          const currentIndex = colors.findIndex(c => dot.classList.contains(c));
          const nextIndex = (currentIndex + 1) % colors.length;

          // Remove all color classes
          colors.forEach(c => dot.classList.remove(c));
          // Add new color
          dot.classList.add(colors[nextIndex]);

          console.log(`[Link] Changed to ${colors[nextIndex]} group`);
          showToast('info', 'Link Color Changed', `Syncing with ${colors[nextIndex]} group`);
        });
      });

      console.log('[Platform] Detach buttons initialized');
    }

    /**
     * Detach a panel to a new window
     */
    function detachPanel(panelKey) {
      const panelConfigs = {
        watchlist: { title: 'Watchlist', width: 350, height: 600 },
        alerts: { title: 'Alerts', width: 400, height: 500 },
        signals: { title: 'AI Signals', width: 400, height: 600 },
        ai: { title: 'AI Assistant', width: 450, height: 650 },
        screener: { title: 'Screener', width: 500, height: 700 },
        pine: { title: 'Pine Script Editor', width: 600, height: 700 },
        calendar: { title: 'Economic Calendar', width: 450, height: 600 },
        news: { title: 'News & Sentiment', width: 450, height: 600 },
        notifications: { title: 'Notifications', width: 350, height: 500 }
      };

      const config = panelConfigs[panelKey];
      if (!config) {
        console.warn(`[Detach] Unknown panel: ${panelKey}`);
        return;
      }

      // Get the panel content
      const panel = document.querySelector(`[data-panel="${panelKey}"]#${panelKey}-panel`);
      if (!panel) {
        console.warn(`[Detach] Panel not found: ${panelKey}`);
        return;
      }

      // Create new window
      const features = `width=${config.width},height=${config.height},menubar=no,toolbar=no,location=no,status=no,resizable=yes,scrollbars=yes`;
      const detachedWindow = window.open('', `panel_${panelKey}_${Date.now()}`, features);

      if (!detachedWindow) {
        showToast('error', 'Popup Blocked', 'Please allow popups for detachable panels');
        return;
      }

      // Write content to new window
      detachedWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>${config.title} - Moon AI Trading</title>
          <link rel="stylesheet" href="src/styles/design-tokens.css">
          <link rel="stylesheet" href="src/styles/tradingview-atomic.css">
          <style>
            body {
              margin: 0;
              padding: 0;
              background: var(--color-bg, #131722);
              color: var(--color-text, rgba(255,255,255,0.9));
              font-family: var(--font-family, -apple-system, sans-serif);
            }
            .detached-panel {
              width: 100%;
              height: 100vh;
              display: flex;
              flex-direction: column;
            }
            .detached-header {
              display: flex;
              justify-content: space-between;
              align-items: center;
              padding: 12px 16px;
              background: var(--color-surface, #1e222d);
              border-bottom: 1px solid var(--color-border, rgba(255,255,255,0.06));
            }
            .detached-header h3 { margin: 0; font-size: 14px; }
            .reattach-btn {
              padding: 6px 12px;
              background: var(--color-primary, #2962ff);
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
            }
            .detached-content {
              flex: 1;
              overflow-y: auto;
              padding: 16px;
            }
          </style>
        </head>
        <body>
          <div class="detached-panel">
            <div class="detached-header">
              <h3>${config.title}</h3>
              <button class="reattach-btn" onclick="window.opener.reattachPanel('${panelKey}'); window.close();">
                Reattach
              </button>
            </div>
            <div class="detached-content">
              ${panel.querySelector('.panel-content').innerHTML}
            </div>
          </div>
          <script>
            // Notify parent window
            window.opener.postMessage({ type: 'panelDetached', panelKey: '${panelKey}' }, '*');
          </script>
        </body>
        </html>
      `);

      // Hide the panel in main window
      panel.style.display = 'none';

      showToast('success', 'Panel Detached', `${config.title} opened in new window`);
      console.log(`[Detach] Panel detached: ${panelKey}`);
    }

    /**
     * Reattach a panel back to main window
     */
    window.reattachPanel = function(panelKey) {
      const panel = document.querySelector(`[data-panel="${panelKey}"]#${panelKey}-panel`);
      if (panel) {
        panel.style.display = 'flex';
        showToast('success', 'Panel Reattached', 'Panel returned to main window');
        console.log(`[Reattach] Panel reattached: ${panelKey}`);
      }
    };

  </script>
</body>
</html>